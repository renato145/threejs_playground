{"version":3,"sources":["CanvasContainer.js","BoxGeometry.js","SurfaceD3.js","SurfaceShader.js","TestShader.js","PlaneGeometry.js","PlaneGeometryShader.js","ShaderTemplate.js","ShaderShapes.js","ShaderTexture.js","App.js","index.js"],"names":["Container","styled","div","Text","CanvasContainer","text","children","xtra","measure","ref","position","Mesh","useRef","useState","hovered","setHover","useFrame","current","rotation","x","y","scale","onPointerOver","onPointerOut","attach","args","color","BoxGeometry","N","m","n","nverts","values","Array","xgrid","ygrid","j","k","i","Math","sin","PI","pow","getData","extent","xmin","xmax","xmid","xrange","ymin","ymax","ymid","yrange","zmin","zmax","zmid","zrange","scalefac","max","scalefacz","getColor","scaleLinear","domain","interpolate","interpolateMagma","useMemo","vertices","colors","push","col","r","g","b","Float32Array","faces","res","M","n0","n1","n2","n3","Uint16Array","rotation-x","onUpdate","self","console","log","computeFaceNormals","computeVertexNormals","attachObject","count","length","array","itemSize","side","DoubleSide","vertexColors","SurfaceD3","shaderData","vertexShader","fragmentShader","SurfaceShader","input","attrs","props","type","boxRef","uniforms","delta","value","displacement","setDisplacement","getDisplacement","useCallback","box","attributes","colorSpeed","useControl","distortionLvl","random","needsUpdate","TestShader","width","min","height","widthSegments","heightSegments","elevation","wireframe","setColors","updatePlaneInfo","plane","setAttribute","Float32BufferAttribute","zValues","filter","o","forEach","useEffect","position-y","PlaneGeometry","PlaneGeometryShader","bounds","mouse","useThree","u_time","u_resolution","Vector2","u_mouse","ShaderTemplate","useMeasure","polyfill","ResizeObserver","ShaderShapes","Xtra","Link","href","target","ShaderTexture","BASE_URL","NLink","NavLink","exact","a","NavBar","SubText","App","to","path","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7c876cb3.chunk.js","sourcesContent":["import React from \"react\";\nimport styled from \"styled-components\";\nimport { Canvas } from \"react-three-fiber\";\nimport { Stats } from \"drei\";\n\nconst Container = styled.div`\n  height: 90vh;\n  width: 100vw;\n  & canvas:focus {\n    outline-width: 0px;\n  }\n`;\n\nexport const Text = styled.div`\n  color: #fff;\n  font-size: 1.2em;\n  text-align: center;\n  padding-top: 0.5em;\n`;\n\nexport const CanvasContainer = ({ text, children, xtra, measure }) => {\n  return (\n    <Container ref={measure}>\n      <Canvas>\n        <ambientLight />\n        <pointLight position={[10, 10, 10]} />\n        {children}\n        <Stats />\n      </Canvas>\n      {xtra && xtra}\n      {text && <Text>{text}</Text>}\n    </Container>\n  );\n};\n","import React, { useRef, useState } from \"react\";\nimport { useFrame } from \"react-three-fiber\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"./CanvasContainer\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const [hovered, setHover] = useState(false);\n\n  useFrame(() => (ref.current.rotation.x = ref.current.rotation.y += 0.01));\n\n  return (\n    <mesh\n      ref={ref}\n      scale={hovered ? [1.5, 1.5, 1.5] : [1, 1, 1]}\n      onPointerOver={() => setHover(true)}\n      onPointerOut={() => setHover(false)}\n    >\n      <boxBufferGeometry attach=\"geometry\" args={[2, 2, 2]} />\n      <meshStandardMaterial\n        attach=\"material\"\n        color={hovered ? \"hotpink\" : \"orange\"}\n      />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const BoxGeometry = () => {\n  return (\n    <CanvasContainer text=\"Simple box geometry with hover event.\">\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useState, useMemo } from \"react\";\nimport { useFrame } from \"react-three-fiber\";\nimport { DoubleSide } from \"three\";\nimport { OrbitControls, Sky } from \"drei\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\nimport { CanvasContainer } from \"./CanvasContainer\";\n\nconst M = 101,\n  N = 101;\n\nconst getData = (m, n) => {\n  var nverts = n * m;\n  var values = new Array(n * m);\n  var xgrid = new Array(n * m);\n  var ygrid = new Array(n * m);\n  for (var j = 0, k = 0; j < m; ++j) {\n    for (var i = 0; i < n; ++i, ++k) {\n      xgrid[k] = i;\n      ygrid[k] = 25 * Math.sin((i * Math.PI) / 50) + j;\n      values[k] = Math.pow(xgrid[k] - 50, 2) + Math.pow(ygrid[k] - 50, 2);\n    }\n  }\n  return { xgrid, ygrid, values, nverts };\n};\n\nconst { xgrid, ygrid, values, nverts } = getData(M, N);\n\n// Obtain centre of grid and scale factors\nconst [xmin, xmax] = extent(xgrid);\nconst xmid = 0.5 * (xmin + xmax);\nconst xrange = xmax - xmin;\n\nconst [ymin, ymax] = extent(ygrid);\nconst ymid = 0.5 * (ymin + ymax);\nconst yrange = ymax - ymin;\n\nconst [zmin, zmax] = extent(values);\nconst zmid = 0.5 * (zmin + zmax);\nconst zrange = zmax - zmin;\n\nconst scalefac = 1.2 / Math.max(xrange, yrange);\nconst scalefacz = 0.5 / zrange;\n\n// color scale\nconst getColor = scaleLinear()\n  .domain(extent(values))\n  .interpolate(() => interpolateMagma);\n\nconst Mesh = () => {\n  const [vertices, colors] = useMemo(() => {\n    const vertices = [];\n    const colors = [];\n    for (let i = 0; i < nverts; i++) {\n      vertices.push((xgrid[i] - xmid) * scalefac);\n      vertices.push((ygrid[i] - ymid) * scalefac);\n      vertices.push((values[i] - zmid) * scalefacz);\n      const col = color(getColor(values[i]));\n      colors.push(col.r/255, col.g/255, col.b/255)\n    }\n    return [new Float32Array(vertices), new Float32Array(colors)];\n  }, []);\n\n  const faces = useMemo(() => {\n    const res = [];\n    for (let j = 0; j < M - 1; j++) {\n      for (let i = 0; i < N - 1; i++) {\n        const n0 = j * N + i;\n        const n1 = n0 + 1;\n        const n2 = (j + 1) * N + i + 1;\n        const n3 = n2 - 1;\n        res.push(n0, n1, n2);\n        res.push(n2, n3, n0);\n      }\n    }\n    return new Uint16Array(res);\n  }, []);\n\n  return (\n    <mesh\n      rotation-x={-Math.PI/2}\n    // ref={ref}\n    scale={[4,4,4]}\n    // onPointerOver={() => setHover(true)}\n    // onPointerOut={() => setHover(false)}\n    >\n      <bufferGeometry\n        attach=\"geometry\"\n        onUpdate={(self) => {\n          console.log(self);\n          self.computeFaceNormals();\n          self.computeVertexNormals();\n        }}\n      >\n        <bufferAttribute\n          attachObject={[\"attributes\", \"position\"]}\n          count={vertices.length / 3}\n          array={vertices}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"color\"]}\n          count={colors.length / 3}\n          array={colors}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attach=\"index\"\n          count={faces.length}\n          array={faces}\n          itemSize={1}\n        />\n      </bufferGeometry>\n      <meshPhongMaterial attach=\"material\" side={DoubleSide} vertexColors={true}  />\n      <OrbitControls />\n      {/* <Sky /> */}\n    </mesh>\n  );\n};\n\nexport const SurfaceD3 = () => {\n  return (\n    <CanvasContainer text='Surface plot using vertex and faces, colored with d3.'>\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo } from \"react\";\nimport { DoubleSide } from \"three\";\nimport { OrbitControls } from \"drei\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\nimport { CanvasContainer } from \"./CanvasContainer\";\n\nconst M = 101,\n  N = 101;\n\nconst getData = (m, n) => {\n  var nverts = n * m;\n  var values = new Array(n * m);\n  var xgrid = new Array(n * m);\n  var ygrid = new Array(n * m);\n  for (var j = 0, k = 0; j < m; ++j) {\n    for (var i = 0; i < n; ++i, ++k) {\n      xgrid[k] = i;\n      ygrid[k] = 25 * Math.sin((i * Math.PI) / 50) + j;\n      values[k] = Math.pow(xgrid[k] - 50, 2) + Math.pow(ygrid[k] - 50, 2);\n    }\n  }\n  return { xgrid, ygrid, values, nverts };\n};\n\nconst { xgrid, ygrid, values, nverts } = getData(M, N);\n\n// Obtain centre of grid and scale factors\nconst [xmin, xmax] = extent(xgrid);\nconst xmid = 0.5 * (xmin + xmax);\nconst xrange = xmax - xmin;\n\nconst [ymin, ymax] = extent(ygrid);\nconst ymid = 0.5 * (ymin + ymax);\nconst yrange = ymax - ymin;\n\nconst [zmin, zmax] = extent(values);\nconst zmid = 0.5 * (zmin + zmax);\nconst zrange = zmax - zmin;\n\nconst scalefac = 1.2 / Math.max(xrange, yrange);\nconst scalefacz = 0.5 / zrange;\n\n// color scale\nconst getColor = scaleLinear()\n  .domain(extent(values))\n  .interpolate(() => interpolateMagma);\n\nconst Mesh = () => {\n  const [vertices, colors] = useMemo(() => {\n    const vertices = [];\n    const colors = [];\n    for (let i = 0; i < nverts; i++) {\n      vertices.push((xgrid[i] - xmid) * scalefac);\n      vertices.push((ygrid[i] - ymid) * scalefac);\n      vertices.push((values[i] - zmid) * scalefacz);\n      const col = color(getColor(values[i]));\n      colors.push(col.r / 255, col.g / 255, col.b / 255);\n    }\n    return [new Float32Array(vertices), new Float32Array(colors)];\n  }, []);\n\n  const faces = useMemo(() => {\n    const res = [];\n    for (let j = 0; j < M - 1; j++) {\n      for (let i = 0; i < N - 1; i++) {\n        const n0 = j * N + i;\n        const n1 = n0 + 1;\n        const n2 = (j + 1) * N + i + 1;\n        const n3 = n2 - 1;\n        res.push(n0, n1, n2);\n        res.push(n2, n3, n0);\n      }\n    }\n    return new Uint16Array(res);\n  }, []);\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  varying float z;\n\n  void main() {\n    vec3 pos = position;\n    z = 0.41 + pos.z*1.5;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = `\n  varying float z;\n  \n  void main() {\n    gl_FragColor = vec4(z, cos(z*200.0), cos(z*100.0), 1.0);\n  }\n`;\n\n    return { vertexShader, fragmentShader };\n  }, []);\n\n  return (\n    <mesh\n      rotation-x={-Math.PI / 2}\n      // ref={ref}\n      scale={[4, 4, 4]}\n      // onPointerOver={() => setHover(true)}\n      // onPointerOut={() => setHover(false)}\n      // onPointerMove={e => console.log(e.unprojectedPoint)}\n    >\n      <bufferGeometry\n        attach=\"geometry\"\n        onUpdate={(self) => {\n          console.log(self);\n          self.computeFaceNormals();\n          self.computeVertexNormals();\n        }}\n      >\n        <bufferAttribute\n          attachObject={[\"attributes\", \"position\"]}\n          count={vertices.length / 3}\n          array={vertices}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"color\"]}\n          count={colors.length / 3}\n          array={colors}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attach=\"index\"\n          count={faces.length}\n          array={faces}\n          itemSize={1}\n        />\n      </bufferGeometry>\n      <shaderMaterial attach=\"material\" {...shaderData} side={DoubleSide}  />\n\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const SurfaceShader = () => {\n  return (\n    <CanvasContainer text='Surface plot using vertex and faces, colored with a custom fragment shader.'>\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useState, useMemo, useCallback } from \"react\";\nimport { useFrame, Dom } from \"react-three-fiber\";\nimport { OrbitControls } from \"drei\";\nimport styled from \"styled-components\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { Controls, useControl } from 'react-three-gui';\n\nconst Slider = styled.input.attrs((props) => ({\n  type: \"range\",\n}))``;\n\nconst Mesh = () => {\n  const ref = useRef();\n  const boxRef = useRef();\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  attribute float displacement;\n  varying float z;\n\n  void main() {\n    vec3 pos = position;\n    z = pos.z;\n    pos.x += (displacement/1.0);\n    // pos.y += cos(displacement/2.0);\n    // pos.y += fract(displacement/2.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = `\n  uniform float delta;\n  varying float z;\n  \n  void main() {\n    gl_FragColor = vec4(z*0.5, 0.5 + cos(delta)*0.25, sin(delta), 1.0);\n  }\n`;\n\n    const uniforms = {\n      delta: { value: 0 },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, []);\n\n  const [displacement, setDisplacement] = useState();\n\n  const getDisplacement = useCallback(\n    (box) => {\n      if (displacement) return;\n      const n = box.attributes.position.count;\n      const res = new Float32Array(n);\n      setDisplacement(res);\n    },\n    [displacement]\n  );\n\n  // const [colorSpeed, setColorSpeed] = useState(0.01);\n  // const [distortionLvl, setDistortionLvl] = useState(0);\n  const colorSpeed = useControl('Color speed', {type: 'number', value: 0.1, max: 10.0})\n  const distortionLvl = useControl('Distortion lvl', {type: 'number', value: 0.0, max: 1.0})\n\n  useFrame(() => {\n    ref.current.rotation.x = ref.current.rotation.y += 0.01;\n    shaderData.uniforms.delta.value += colorSpeed;\n    for (let i = 0; i < displacement.length; i++) {\n      displacement[i] = Math.random() * distortionLvl;\n    }\n    boxRef.current.attributes.displacement.needsUpdate = true;\n  });\n\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry\n        ref={boxRef}\n        attach=\"geometry\"\n        args={[3, 3, 3]}\n        onUpdate={(self) => getDisplacement(self)}\n      >\n        {displacement && (\n          <bufferAttribute\n            attachObject={[\"attributes\", \"displacement\"]}\n            count={displacement.length}\n            array={displacement}\n            itemSize={1}\n          />\n        )}\n      </boxBufferGeometry>\n      <shaderMaterial attach=\"material\" {...shaderData} />\n      <OrbitControls />\n      {/* <Dom\n        style={{ transform: \"\" }}\n        // center\n        // position={[100,0,100]}\n      >\n        <Slider />\n      </Dom> */}\n    </mesh>\n  );\n};\n\nexport const TestShader = () => {\n  return (\n    <CanvasContainer text=\"Testing the use of shaders.\" xtra={<Controls />}>\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useCallback, useEffect, useState } from \"react\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { DoubleSide, Float32BufferAttribute } from \"three\";\nimport { Controls, useControl } from \"react-three-gui\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const width = useControl(\"width\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const height = useControl(\"height\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const widthSegments = useControl(\"width segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const heightSegments = useControl(\"height segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const elevation = useControl(\"max elevation\", {\n    type: \"number\",\n    value: 0.25,\n    min: 0,\n    max: 2,\n  });\n  const wireframe = useControl(\"wireframe\", { type: \"boolean\", value: false });\n\n  const [colors, setColors] = useState([]);\n\n  const updatePlaneInfo = useCallback(\n    (plane) => {\n      const vertices = plane.attributes.position.array;\n      for (let i = 0; i < vertices.length; i++) {\n        if (i % 3 === 2) vertices[i] = Math.random() * elevation;\n      }\n\n      if (colors && colors.length === vertices.length) {\n        plane.setAttribute('color', new Float32BufferAttribute(colors, 3));\n      } else {\n        const zValues = [...vertices.filter((o, i) => i % 3 === 2)];\n\n        const getColor = scaleLinear()\n          .domain(extent(zValues))\n          .interpolate(() => interpolateMagma);\n\n        const vertexColors = [];\n        zValues.forEach((o) => {\n          const col = color(getColor(o));\n          vertexColors.push(col.r / 255, col.g / 255, col.b / 255);\n        });\n        setColors(() => {\n          plane.setAttribute('color', new Float32BufferAttribute(vertexColors, 3));\n          return vertexColors;\n        });\n      }\n\n      // if (plane.attributes.color) plane.attributes.color.needsUpdate = true;\n    },\n    [colors, elevation]\n  );\n\n  useEffect(() => {\n    updatePlaneInfo(ref.current);\n    ref.current.attributes.position.needsUpdate = true;\n  }, [elevation, updatePlaneInfo]);\n\n  return (\n    <mesh rotation-x={-Math.PI / 2} position-y={-1.5}>\n      <planeBufferGeometry\n        ref={ref}\n        attach=\"geometry\"\n        args={[width, height, widthSegments, heightSegments]}\n        onUpdate={(self) => updatePlaneInfo(self)}\n      >\n      </planeBufferGeometry>\n      <meshPhongMaterial\n        attach=\"material\"\n        side={DoubleSide}\n        wireframe={wireframe}\n        vertexColors={true}\n      />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const PlaneGeometry = () => {\n  return (\n    <CanvasContainer\n      text=\"Using a plane buffer geometry to show a surface plot, with colors given by d3.\"\n      xtra={<Controls />}\n    >\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useCallback, useEffect, useMemo } from \"react\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { DoubleSide } from \"three\";\nimport { Controls, useControl } from \"react-three-gui\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const width = useControl(\"width\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const height = useControl(\"height\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const widthSegments = useControl(\"width segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const heightSegments = useControl(\"height segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const elevation = useControl(\"max elevation\", {\n    type: \"number\",\n    value: 0.35,\n    min: 0,\n    max: 2,\n  });\n  const wireframe = useControl(\"wireframe\", { type: \"boolean\", value: false });\n\n  const updatePlaneInfo = useCallback(\n    (plane) => {\n      const vertices = plane.attributes.position.array;\n      for (let i = 0; i < vertices.length; i++) {\n        if (i % 3 === 2) vertices[i] = Math.random() * elevation;\n      }\n    },\n    [elevation]\n  );\n\n  useEffect(() => {\n    updatePlaneInfo(ref.current);\n    ref.current.attributes.position.needsUpdate = true;\n  }, [elevation, updatePlaneInfo]);\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  varying float z;\n\n  void main() {\n    vec3 pos = position;\n    z = pos.z;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = `\n  varying float z;\n  \n  void main() {\n    gl_FragColor = vec4(z, 0.1, 0.3, 1.0);\n  }\n`;\n\n    return { vertexShader, fragmentShader };\n  }, []);\n\n  return (\n    <mesh rotation-x={-Math.PI / 2} position-y={-1.5}>\n      <planeBufferGeometry\n        ref={ref}\n        attach=\"geometry\"\n        args={[width, height, widthSegments, heightSegments]}\n        onUpdate={(self) => updatePlaneInfo(self)}\n      >\n      </planeBufferGeometry>\n      <shaderMaterial attach=\"material\" {...shaderData} side={DoubleSide} wireframe={wireframe} />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const PlaneGeometryShader = () => {\n  return (\n    <CanvasContainer\n      text=\"Using a plane buffer geometry to show a surface plot, with colors given by a fragment shader.\"\n      xtra={<Controls />}\n    >\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo, useEffect } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { useThree, useFrame } from \"react-three-fiber\";\n\nconst Mesh = ({ bounds }) => {\n  const { mouse } = useThree();\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = `\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n\n\n  void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.y += sin(u_time) * 0.05;\n    vec2 mouse = (u_mouse + 1.0) / 2.0;\n    gl_FragColor=vec4(st.x, st.y, (mouse.x + mouse.y) / 2.0, 1.0);\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [ mouse ]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nexport const ShaderTemplate = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n\n  return (\n    <CanvasContainer text=\"Basic template to play with shaders.\" measure={ref}>\n      <Mesh bounds={bounds} />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo, useEffect } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { useThree, useFrame } from \"react-three-fiber\";\n\nconst Mesh = ({ bounds }) => {\n  const { mouse } = useThree();\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = `\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n\n  void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 mouse = u_mouse;\n\n    // Borders\n    // vec2 bl = smoothstep(0.05, 0.5, st);\n    // float pct = bl.x * bl.y;\n    // vec2 tr = step(0.05, 1.0 - st);\n    // pct *= tr.x * tr.y;\n    // color = vec3(pct);\n\n    // Circle\n    // float pct = distance(st, vec2(0.5));\n    // color = vec3(pct);\n\n    // Repeating circles\n    float d = 0.0;\n    st = st * 2. - 1.; // normalize between 0-1\n    st.x -= mouse.x;\n    // st.y -= mouse.y;\n    st.y = step(1.0, st.y);\n    // st.y = smoothstep(-1.0, 1.0, st.y);\n    d = length( abs(st) - sin(u_time/20.0) );\n    color = vec3(st.x, st.y + mouse.y*0.25, 0.0);\n    color.b += (mouse.x + 1.0) / 2.0 * 0.35;\n    color += fract(d*12.0);\n\n    gl_FragColor=vec4(color, 1.0);\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [ mouse ]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nexport const ShaderShapes = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n\n  return (\n    <CanvasContainer text=\"Playing with shapes on shaders.\" measure={ref}>\n      <Mesh bounds={bounds} />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo, useEffect } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { CanvasContainer, Text } from \"./CanvasContainer\";\nimport { Link } from \"./App\";\nimport { useThree, useFrame } from \"react-three-fiber\";\n\nconst Mesh = ({ bounds }) => {\n  const { mouse } = useThree();\n\n  // credits to https://www.shadertoy.com/view/MdSXzz\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = `\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n\n  const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n  float hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n  }\n\n  float noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                    hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                    hash( i + vec2(1.0,1.0) ), u.x), u.y);\n  }\n\n  float fbm( vec2 p )\n  {\n      float f = 0.0;\n      f += 0.5000*noise( p ); p = m*p*2.02;\n      f += 0.2500*noise( p ); p = m*p*2.03;\n      f += 0.1250*noise( p ); p = m*p*2.01;\n      f += 0.0625*noise( p );\n      return f/0.9375;\n  }\n\n  vec2 fbm2( in vec2 p )\n  {\n      return vec2( fbm(p.xy), fbm(p.yx) );\n  }\n\n  vec3 map( vec2 p )\n  {   \n      p *= 0.7;\n      float t = u_time * ( 1.0 + 2. * distance(u_mouse, vec2(0.0)));\n\n      float f = dot( fbm2( 1.0*(0.05*t + p + fbm2(-0.05*t+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) );\n\n      float bl = smoothstep( -0.8, 0.8, f );\n\n      float ti = smoothstep( -1.0, 1.0, fbm(p) );\n\n      return mix( mix( vec3(0.50,0.00,0.00), \n                       vec3(1.00,0.75,0.35), ti ), \n                       vec3(0.00,0.00,0.02), bl );\n  }\n\n  void main() {\n    vec2 p = (-u_resolution.xy+2.0*gl_FragCoord.xy)/u_resolution.y;\n\n    float e = 0.0045;\n\n    vec3 colc = map( p               ); float gc = dot(colc,vec3(0.433));\n    vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333));\n    vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333));\n    \n    vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n\n    vec3 col = colc;\n    col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb);\n    col *= 1.0+0.2*nor.y*nor.y;\n    col += 0.05*nor.y*nor.y*nor.y;\n    \n    \n    vec2 q = gl_FragCoord.xy/u_resolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    vec2 m = (u_mouse.xy + 1.0 ) / 2.0;\n    col.r *= m.x;\n    col.g *= m.y;\n    \n    gl_FragColor = vec4( col, 1.0 );\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [mouse]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nconst Xtra = () => (\n  <Text>\n    A more complex test (inspired by{\" \"}\n    {\n      <Link href=\"https://www.shadertoy.com/view/MdSXzz\" target=\"_black\">\n        this work\n      </Link>\n    }\n    ).\n  </Text>\n);\n\nexport const ShaderTexture = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n\n  return (\n    <CanvasContainer xtra={<Xtra />} measure={ref}>\n      <Mesh bounds={bounds} />\n    </CanvasContainer>\n  );\n};\n","import React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Route,\n  NavLink,\n  Switch,\n} from \"react-router-dom\";\nimport styled from \"styled-components\";\nimport { BoxGeometry } from \"./BoxGeometry\";\nimport { SurfaceD3 } from \"./SurfaceD3\";\nimport { SurfaceShader } from \"./SurfaceShader\";\nimport { TestShader } from \"./TestShader\";\nimport { PlaneGeometry } from \"./PlaneGeometry\";\nimport { PlaneGeometryShader } from \"./PlaneGeometryShader\";\nimport { ShaderTemplate } from './ShaderTemplate';\nimport { ShaderShapes } from './ShaderShapes';\nimport { ShaderTexture } from './ShaderTexture';\nimport \"./App.css\";\n\nconst BASE_URL = \"threejs_playground\";\n\nconst NLink = styled(NavLink).attrs((props) => ({\n  exact: true,\n}))`\n  color: #abc;\n  font-size: 1rem;\n  &.active {\n    color: #fff;\n  }\n`;\n\nexport const Link = styled.a`\n  color: #abc;\n  font-size: 1rem;\n  &.active {\n    color: #fff;\n  }\n`;\n\nconst NavBar = styled.div`\n  position: absolute;\n  display: flex;\n  flex-wrap: wrap;\n  flex-flow: column;\n  justify-content: space-between;\n  margin-top: 3rem;\n  padding: 1em 1em;\n  background-color: rgba(0, 0, 0, 0.6);\n  z-index: 100;\n\n  & > div {\n    padding-bottom: 0.5rem;\n  }\n`;\n\nconst Text = styled.div`\n  color: #fff;\n  font-size: 2em;\n  text-align: center;\n  padding-top: 2em;\n`;\n\nconst SubText = styled.div`\n  color: #fff;\n  font-size: 1.2em;\n  text-align: center;\n  padding-top: 3em;\n`;\n\nconst App = () => {\n  return (\n    <Router>\n      <NavBar>\n        <div>\n          <NLink to={`/${BASE_URL}/`}>Home</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/BoxGeometry`}>BoxGeometry</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/SurfaceD3`}>SurfaceD3</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/SurfaceShader`}>SurfaceShader</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/TestShader`}>TestShader</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/PlaneGeometry`}>PlaneGeometry</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/PlaneGeometryShader`}>PlaneGeometryShader</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/ShaderTemplate`}>ShaderTemplate</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/ShaderShapes`}>ShaderShapes</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/ShaderTexture`}>ShaderTexture</NLink>\n        </div>\n        <div>\n          <Link\n            href=\"https://github.com/renato145/threejs_playground/\"\n            target=\"_black\"\n          >\n            Source Code\n          </Link>\n        </div>\n      </NavBar>\n      <Switch>\n        <Route exact path={`/${BASE_URL}/`}>\n          <Text>Threejs playground</Text>\n          <SubText>\n            Made by: Renato Hermoza, check the{\" \"}\n            <Link\n              href=\"https://github.com/renato145/threejs_playground/\"\n              target=\"_black\"\n            >\n              source code\n            </Link>\n            .\n          </SubText>\n        </Route>\n        <Route path={`/${BASE_URL}/BoxGeometry`}>\n          <BoxGeometry />\n        </Route>\n        <Route path={`/${BASE_URL}/SurfaceD3`}>\n          <SurfaceD3 />\n        </Route>\n        <Route path={`/${BASE_URL}/SurfaceShader`}>\n          <SurfaceShader />\n        </Route>\n        <Route path={`/${BASE_URL}/TestShader`}>\n          <TestShader />\n        </Route>\n        <Route path={`/${BASE_URL}/PlaneGeometry`}>\n          <PlaneGeometry />\n        </Route>\n        <Route path={`/${BASE_URL}/PlaneGeometryShader`}>\n          <PlaneGeometryShader />\n        </Route>\n        <Route path={`/${BASE_URL}/ShaderTemplate`}>\n          <ShaderTemplate />\n        </Route>\n        <Route path={`/${BASE_URL}/ShaderShapes`}>\n          <ShaderShapes />\n        </Route>\n        <Route path={`/${BASE_URL}/ShaderTexture`}>\n          <ShaderTexture />\n        </Route>\n      </Switch>\n    </Router>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}