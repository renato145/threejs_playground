{"version":3,"sources":["components/CanvasContainer.js","shaders/BoxGeometry.js","shaders/SurfaceD3.js","utils.js","components/ButtonImageUpload.js","components/ShaderEditorLayout.js","shaders/SurfaceShader.js","shaders/CubeShader.js","shaders/PlaneGeometry.js","shaders/PlaneGeometryShader.js","shaders/ShaderTemplate.js","shaders/ShaderShapes.js","shaders/ShaderTexture.js","shaders/FractalKoch.js","shaders/FractalMandelBrot.js","shaders/ExplodingSphere.js","shaders/ShaderEditor.js","App.js","index.js","shaders/textures/texture1.png"],"names":["Text","children","tw","props","className","CanvasContainer","text","xtra","measure","ref","position","Mesh","useRef","useState","hovered","setHover","useFrame","current","rotation","x","y","scale","onPointerOver","onPointerOut","attach","args","color","BoxGeometry","N","m","n","nverts","values","Array","xgrid","ygrid","j","k","i","Math","sin","PI","pow","getData","extent","xmin","xmax","xmid","xrange","ymin","ymax","ymid","yrange","zmin","zmax","zmid","zrange","scalefac","max","scalefacz","getColor","scaleLinear","domain","interpolate","interpolateMagma","useMemo","vertices","colors","push","col","r","g","b","Float32Array","faces","res","M","n0","n1","n2","n3","Uint16Array","rotation-x","onUpdate","self","computeFaceNormals","computeVertexNormals","attachObject","count","length","array","itemSize","side","DoubleSide","vertexColors","SurfaceD3","loadTexture","url","TextureLoader","load","wrapS","RepeatWrapping","wrapT","ButtonImageUpload","handleUpload","type","accept","onChange","onClick","click","vertexShaderCode","fragmentShaderCode","textureUrl","materialSide","useThree","mouse","clock","aspect","useUpdate","material","vertexShader","fragmentShader","needsUpdate","uniforms","u_time","value","u_aspect","u_mouse","u_texture","useEffect","elapsedTime","CodeEditor","code","setCode","style","highlight","useCallback","defaultProps","theme","language","tokens","getLineProps","getTokenProps","map","line","key","token","onValueChange","padding","textareaClassName","fontSize","overflow","boxSizing","fontFamily","plain","ShaderEditorLayout","texture","description","doShowCode","FrontSide","textureEnable","setTextureUrl","e","URL","createObjectURL","target","files","setVertexShaderCode","setFragmentShaderCode","showCode","setShowCode","xtra_content","handleClick","show","SurfaceShader","boxRef","shaderData","delta","displacement","setDisplacement","getDisplacement","box","attributes","colorSpeed","useControl","distortionLvl","random","CubeShader","width","min","height","widthSegments","heightSegments","elevation","wireframe","setColors","updatePlaneInfo","plane","setAttribute","Float32BufferAttribute","zValues","filter","o","forEach","position-y","PlaneGeometry","PlaneGeometryShader","ShaderTemplate","ShaderShapes","bounds","u_resolution","Vector2","Xtra","href","ShaderTexture","useMeasure","polyfill","ResizeObserver","FractalKoch","exampleTexture","FractalMandelBrot","useResource","geometry","randomDirections","undefined","randomStrengths","triangleCount","getAttribute","vec3","Vector3","directions","set","fill","multiplyScalar","subScalar","normalize","toArray","flat","u_explosion","ExplodingSphere","ShaderEditor","NLink","activeClassName","exact","NavBar","styled","div","isHome","HomeContent","AppContent","useLocation","pathname","to","path","App","basename","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.b6354827.chunk.js","sourcesContent":["import React from \"react\";\nimport { Canvas } from \"react-three-fiber\";\nimport { Stats } from \"drei\";\n\nexport const Text = ({ children, tw=\"\", ...props }) => (\n  <div className={`text-center lg:text-lg ${tw}`} {...props}>\n    <p>{children}</p>\n  </div>\n);\n\nexport const CanvasContainer = ({\n  text,\n  children,\n  xtra,\n  measure,\n  ...props\n}) => {\n  return (\n    <div className=\"w-full h-screen flex flex-col\">\n      <div ref={measure} className=\"flex-auto\" {...props}>\n        <Canvas>\n          <ambientLight />\n          <pointLight position={[10, 10, 10]} />\n          {children}\n          <Stats />\n        </Canvas>\n      </div>\n      <div className=\"py-2 flex justify-center items-center\">\n        {text && <Text>{text}</Text>}\n        {xtra && xtra}\n      </div>\n    </div>\n  );\n};\n","import React, { useRef, useState } from \"react\";\nimport { useFrame } from \"react-three-fiber\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"../components/CanvasContainer\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const [hovered, setHover] = useState(false);\n\n  useFrame(() => (ref.current.rotation.x = ref.current.rotation.y += 0.01));\n\n  return (\n    <mesh\n      ref={ref}\n      scale={hovered ? [1.5, 1.5, 1.5] : [1, 1, 1]}\n      onPointerOver={() => setHover(true)}\n      onPointerOut={() => setHover(false)}\n    >\n      <boxBufferGeometry attach=\"geometry\" args={[2, 2, 2]} />\n      <meshStandardMaterial\n        attach=\"material\"\n        color={hovered ? \"hotpink\" : \"orange\"}\n      />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const BoxGeometry = () => {\n  return (\n    <CanvasContainer text=\"Simple box geometry with hover event.\">\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo } from \"react\";\nimport { DoubleSide } from \"three\";\nimport { OrbitControls } from \"drei\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\nimport { CanvasContainer } from \"../components/CanvasContainer\";\n\nconst M = 101,\n  N = 101;\n\nconst getData = (m, n) => {\n  var nverts = n * m;\n  var values = new Array(n * m);\n  var xgrid = new Array(n * m);\n  var ygrid = new Array(n * m);\n  for (var j = 0, k = 0; j < m; ++j) {\n    for (var i = 0; i < n; ++i, ++k) {\n      xgrid[k] = i;\n      ygrid[k] = 25 * Math.sin((i * Math.PI) / 50) + j;\n      values[k] = Math.pow(xgrid[k] - 50, 2) + Math.pow(ygrid[k] - 50, 2);\n    }\n  }\n  return { xgrid, ygrid, values, nverts };\n};\n\nconst { xgrid, ygrid, values, nverts } = getData(M, N);\n\n// Obtain centre of grid and scale factors\nconst [xmin, xmax] = extent(xgrid);\nconst xmid = 0.5 * (xmin + xmax);\nconst xrange = xmax - xmin;\n\nconst [ymin, ymax] = extent(ygrid);\nconst ymid = 0.5 * (ymin + ymax);\nconst yrange = ymax - ymin;\n\nconst [zmin, zmax] = extent(values);\nconst zmid = 0.5 * (zmin + zmax);\nconst zrange = zmax - zmin;\n\nconst scalefac = 1.2 / Math.max(xrange, yrange);\nconst scalefacz = 0.5 / zrange;\n\n// color scale\nconst getColor = scaleLinear()\n  .domain(extent(values))\n  .interpolate(() => interpolateMagma);\n\nconst Mesh = () => {\n  const [vertices, colors] = useMemo(() => {\n    const vertices = [];\n    const colors = [];\n    for (let i = 0; i < nverts; i++) {\n      vertices.push((xgrid[i] - xmid) * scalefac);\n      vertices.push((ygrid[i] - ymid) * scalefac);\n      vertices.push((values[i] - zmid) * scalefacz);\n      const col = color(getColor(values[i]));\n      colors.push(col.r / 255, col.g / 255, col.b / 255);\n    }\n    return [new Float32Array(vertices), new Float32Array(colors)];\n  }, []);\n\n  const faces = useMemo(() => {\n    const res = [];\n    for (let j = 0; j < M - 1; j++) {\n      for (let i = 0; i < N - 1; i++) {\n        const n0 = j * N + i;\n        const n1 = n0 + 1;\n        const n2 = (j + 1) * N + i + 1;\n        const n3 = n2 - 1;\n        res.push(n0, n1, n2);\n        res.push(n2, n3, n0);\n      }\n    }\n    return new Uint16Array(res);\n  }, []);\n\n  return (\n    <mesh rotation-x={-Math.PI / 2} scale={[4, 4, 4]}>\n      <bufferGeometry\n        attach=\"geometry\"\n        onUpdate={(self) => {\n          self.computeFaceNormals();\n          self.computeVertexNormals();\n        }}\n      >\n        <bufferAttribute\n          attachObject={[\"attributes\", \"position\"]}\n          count={vertices.length / 3}\n          array={vertices}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"color\"]}\n          count={colors.length / 3}\n          array={colors}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attach=\"index\"\n          count={faces.length}\n          array={faces}\n          itemSize={1}\n        />\n      </bufferGeometry>\n      <meshPhongMaterial\n        attach=\"material\"\n        side={DoubleSide}\n        vertexColors={true}\n      />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const SurfaceD3 = () => {\n  return (\n    <CanvasContainer text=\"Surface plot using vertex and faces, colored with d3.\">\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import { TextureLoader, RepeatWrapping } from \"three\";\n\nexport const loadTexture = url => {\n  const res = new TextureLoader().load(url);\n  res.wrapS = RepeatWrapping;\n  res.wrapT = RepeatWrapping;\n  return res;\n}\n","import React, { useRef } from \"react\";\n\nexport const ButtonImageUpload = ({\n  children,\n  handleUpload = () => {},\n  ...props\n}) => {\n  const ref = useRef();\n\n  return (\n    <div className=\"text-sm ml-2\">\n      <input\n        ref={ref}\n        type=\"file\"\n        className=\"hidden\"\n        accept=\"image/*\"\n        onChange={handleUpload}\n      />\n      <button {...props} onClick={() => ref.current.click()}>\n        {children}\n      </button>\n    </div>\n  );\n};\n","import React, { useMemo, useEffect, useState, useCallback } from \"react\";\nimport { FrontSide } from \"three\";\nimport { useThree, useFrame, useUpdate } from \"react-three-fiber\";\nimport Editor from \"react-simple-code-editor\";\nimport Highlight, { defaultProps } from \"prism-react-renderer\";\nimport theme from \"prism-react-renderer/themes/nightOwl\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { loadTexture } from \"../utils\";\nimport { ButtonImageUpload } from \"./ButtonImageUpload\";\nimport \"./ShaderEditorLayout.css\";\n\nconst Mesh = ({\n  children,\n  vertexShaderCode,\n  fragmentShaderCode,\n  textureUrl,\n  materialSide,\n  ...props\n}) => {\n  const { mouse, clock, aspect } = useThree();\n  const ref = useUpdate(\n    (material) => {\n      material.vertexShader = vertexShaderCode;\n      material.fragmentShader = fragmentShaderCode;\n      material.needsUpdate = true;\n    },\n    [vertexShaderCode, fragmentShaderCode]\n  );\n\n  const uniforms = useMemo(\n    () => ({\n      u_time: { value: 0 },\n      u_aspect: { value: 1 },\n      u_mouse: { value: mouse },\n      u_texture: { value: 0 },\n    }),\n    [mouse]\n  );\n\n  useEffect(() => void (uniforms.u_aspect.value = aspect), [aspect, uniforms]);\n\n  useEffect(() => {\n    if (textureUrl) uniforms.u_texture.value = loadTexture(textureUrl);\n  }, [textureUrl, uniforms]);\n\n  useFrame(() => {\n    uniforms.u_time.value += clock.elapsedTime / 1000; //miliseconds\n  });\n\n  return (\n    <mesh {...props}>\n      {children}\n      <shaderMaterial\n        ref={ref}\n        attach=\"material\"\n        uniforms={uniforms}\n        side={materialSide}\n      />\n    </mesh>\n  );\n};\n\nconst CodeEditor = ({ code, setCode, className = \"\", ...style }) => {\n  const highlight = useCallback(\n    (code) => (\n      <Highlight {...defaultProps} theme={theme} code={code} language=\"jsx\">\n        {({ tokens, getLineProps, getTokenProps }) => (\n          <div>\n            {tokens.map((line, i) => (\n              <div {...getLineProps({ line, key: i })}>\n                <>\n                  {line.map((token, key) => (\n                    <span key={key} {...getTokenProps({ token, key })} />\n                  ))}\n                </>\n              </div>\n            ))}\n          </div>\n        )}\n      </Highlight>\n    ),\n    []\n  );\n\n  return (\n    <Editor\n      value={code}\n      onValueChange={setCode}\n      highlight={highlight}\n      padding={10}\n      textareaClassName=\"editor-text-area\"\n      className={className}\n      style={{\n        fontSize: \"0.8em\",\n        overflow: \"auto\",\n        boxSizing: \"border-box\",\n        fontFamily: '\"Dank Mono\", \"Fira Code\", monospace',\n        ...theme.plain,\n        ...style,\n      }}\n    />\n  );\n};\n\nexport const ShaderEditorLayout = ({\n  children,\n  texture,\n  description,\n  vertexShader,\n  fragmentShader,\n  xtra,\n  doShowCode=false,\n  materialSide = FrontSide,\n  textureEnable = true,\n  ...props\n}) => {\n  const [textureUrl, setTextureUrl] = useState(texture);\n  const handleUpload = (e) => {\n    const url = URL.createObjectURL(e.target.files[0]);\n    setTextureUrl(url);\n  };\n  const [vertexShaderCode, setVertexShaderCode] = useState(vertexShader);\n  const [fragmentShaderCode, setFragmentShaderCode] = useState(fragmentShader);\n  const [showCode, setShowCode] = useState(doShowCode);\n\n  const xtra_content = useMemo(() => {\n    if (!xtra && !textureEnable) return false;\n    return (\n      <>\n        {xtra}\n        <ButtonImageUpload handleUpload={handleUpload}>\n          Upload texture\n        </ButtonImageUpload>\n      </>\n    );\n  }, [textureEnable, xtra]);\n\n  const handleClick = useCallback(() => setShowCode((show) => !show), []);\n\n  return (\n    <div>\n      <div className=\"w-full grid grid-cols-6 grid-flow-row\">\n        <div className={`row-span-2 ${showCode ? \"col-span-3 xl:col-span-4\" : \"col-span-6\"}`}>\n          <CanvasContainer text={description} xtra={xtra_content}>\n            <Mesh\n              vertexShaderCode={vertexShaderCode}\n              fragmentShaderCode={fragmentShaderCode}\n              textureUrl={textureUrl}\n              materialSide={materialSide}\n              {...props}\n            >\n              {children}\n            </Mesh>\n          </CanvasContainer>\n        </div>\n        {showCode && (\n          <>\n        <div className=\"col-span-3 xl:col-span-2\">\n          <CodeEditor\n            code={vertexShaderCode}\n            className=\"h-screen-49\"\n            setCode={setVertexShaderCode}\n            />\n        </div>\n        <div className=\"col-span-3 xl:col-span-2\">\n          <CodeEditor\n            code={fragmentShaderCode}\n            className=\"h-screen-49\"\n            setCode={setFragmentShaderCode}\n            />\n        </div>\n          </>\n        )}\n      </div>\n      <div className=\"fixed top-0 right-0 mr-4\">\n        <button\n          className=\"text-sm font-semibold opacity-75 focus:opacity-100 focus:shadow-none\"\n          onClick={() => handleClick()}\n          >\n          {showCode ? \"Hide editor\" : \"Show editor\"}\n        </button>\n      </div>\n    </div>\n  );\n};\n","import React, { useMemo } from \"react\";\nimport { DoubleSide } from \"three\";\nimport { OrbitControls } from \"drei\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\nimport { ShaderEditorLayout } from \"../components/ShaderEditorLayout\";\n\nconst M = 101,\n  N = 101;\n\nconst getData = (m, n) => {\n  var nverts = n * m;\n  var values = new Array(n * m);\n  var xgrid = new Array(n * m);\n  var ygrid = new Array(n * m);\n  for (var j = 0, k = 0; j < m; ++j) {\n    for (var i = 0; i < n; ++i, ++k) {\n      xgrid[k] = i;\n      ygrid[k] = 25 * Math.sin((i * Math.PI) / 50) + j;\n      values[k] = Math.pow(xgrid[k] - 50, 2) + Math.pow(ygrid[k] - 50, 2);\n    }\n  }\n  return { xgrid, ygrid, values, nverts };\n};\n\nconst { xgrid, ygrid, values, nverts } = getData(M, N);\n\n// Obtain centre of grid and scale factors\nconst [xmin, xmax] = extent(xgrid);\nconst xmid = 0.5 * (xmin + xmax);\nconst xrange = xmax - xmin;\n\nconst [ymin, ymax] = extent(ygrid);\nconst ymid = 0.5 * (ymin + ymax);\nconst yrange = ymax - ymin;\n\nconst [zmin, zmax] = extent(values);\nconst zmid = 0.5 * (zmin + zmax);\nconst zrange = zmax - zmin;\n\nconst scalefac = 1.2 / Math.max(xrange, yrange);\nconst scalefacz = 0.5 / zrange;\n\n// color scale\nconst getColor = scaleLinear()\n  .domain(extent(values))\n  .interpolate(() => interpolateMagma);\n\nconst VERTEX_SHADER = /*glsl*/`\n  varying float z;\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n    vec3 pos = position;\n    z = 0.41 + pos.z*1.5;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\nconst FRAGMENT_SHADER = /*glsl*/`\n  varying float z;\n  varying vec2 vUv;\n  uniform float u_time;\n  uniform float u_aspect;\n  uniform vec2 u_mouse;\n  uniform sampler2D u_texture;\n  \n  void main() {\n    gl_FragColor = vec4(z, cos(z*200.0), cos(z*100.0), 1.0);\n  }\n`;\n\n\nexport const SurfaceShader = () => {\n  const [vertices, colors] = useMemo(() => {\n    const vertices = [];\n    const colors = [];\n    for (let i = 0; i < nverts; i++) {\n      vertices.push((xgrid[i] - xmid) * scalefac);\n      vertices.push((ygrid[i] - ymid) * scalefac);\n      vertices.push((values[i] - zmid) * scalefacz);\n      const col = color(getColor(values[i]));\n      colors.push(col.r / 255, col.g / 255, col.b / 255);\n    }\n    return [new Float32Array(vertices), new Float32Array(colors)];\n  }, []);\n\n  const faces = useMemo(() => {\n    const res = [];\n    for (let j = 0; j < M - 1; j++) {\n      for (let i = 0; i < N - 1; i++) {\n        const n0 = j * N + i;\n        const n1 = n0 + 1;\n        const n2 = (j + 1) * N + i + 1;\n        const n3 = n2 - 1;\n        res.push(n0, n1, n2);\n        res.push(n2, n3, n0);\n      }\n    }\n    return new Uint16Array(res);\n  }, []);\n\n\n  return (\n    <ShaderEditorLayout\n      description=\"Surface plot using vertex and faces, colored with a custom fragment shader.\"\n      textureEnable={false}\n      vertexShader={VERTEX_SHADER}\n      fragmentShader={FRAGMENT_SHADER}\n      materialSide={DoubleSide}\n      rotation-x={-Math.PI / 2}\n      scale={[4, 4, 4]}\n    >\n      <bufferGeometry\n        attach=\"geometry\"\n        onUpdate={(self) => {\n          self.computeFaceNormals();\n          self.computeVertexNormals();\n        }}\n      >\n        <bufferAttribute\n          attachObject={[\"attributes\", \"position\"]}\n          count={vertices.length / 3}\n          array={vertices}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"color\"]}\n          count={colors.length / 3}\n          array={colors}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attach=\"index\"\n          count={faces.length}\n          array={faces}\n          itemSize={1}\n        />\n      </bufferGeometry>\n      <OrbitControls />\n    </ShaderEditorLayout>\n  );\n};\n","import React, { useRef, useState, useMemo, useCallback } from \"react\";\nimport { useFrame } from \"react-three-fiber\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"../components/CanvasContainer\";\nimport { Controls, useControl } from 'react-three-gui';\n\nconst Mesh = () => {\n  const ref = useRef();\n  const boxRef = useRef();\n\n  const shaderData = useMemo(() => {\n    const vertexShader = /*glsl*/`\n  attribute float displacement;\n  varying float z;\n\n  void main() {\n    vec3 pos = position;\n    z = pos.z;\n    pos.x += (displacement/1.0);\n    // pos.y += cos(displacement/2.0);\n    // pos.y += fract(displacement/2.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = /*glsl*/`\n  uniform float delta;\n  varying float z;\n  \n  void main() {\n    gl_FragColor = vec4(z*0.5, 0.5 + cos(delta)*0.25, sin(delta), 1.0);\n  }\n`;\n\n    const uniforms = {\n      delta: { value: 0 },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, []);\n\n  const [displacement, setDisplacement] = useState();\n\n  const getDisplacement = useCallback(\n    (box) => {\n      if (displacement) return;\n      const n = box.attributes.position.count;\n      const res = new Float32Array(n);\n      setDisplacement(res);\n    },\n    [displacement]\n  );\n\n  const colorSpeed = useControl('Color speed', {type: 'number', value: 0.1, max: 10.0})\n  const distortionLvl = useControl('Distortion lvl', {type: 'number', value: 0.0, max: 1.0})\n\n  useFrame(() => {\n    ref.current.rotation.x = ref.current.rotation.y += 0.01;\n    shaderData.uniforms.delta.value += colorSpeed;\n    for (let i = 0; i < displacement.length; i++) {\n      displacement[i] = Math.random() * distortionLvl;\n    }\n    boxRef.current.attributes.displacement.needsUpdate = true;\n  });\n\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry\n        ref={boxRef}\n        attach=\"geometry\"\n        args={[3, 3, 3]}\n        onUpdate={(self) => getDisplacement(self)}\n      >\n        {displacement && (\n          <bufferAttribute\n            attachObject={[\"attributes\", \"displacement\"]}\n            count={displacement.length}\n            array={displacement}\n            itemSize={1}\n          />\n        )}\n      </boxBufferGeometry>\n      <shaderMaterial attach=\"material\" {...shaderData} />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const CubeShader = () => {\n  return (\n    <CanvasContainer text=\"Testing the use of shaders.\" xtra={<Controls />}>\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useCallback, useEffect, useState } from \"react\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"../components/CanvasContainer\";\nimport { DoubleSide, Float32BufferAttribute } from \"three\";\nimport { Controls, useControl } from \"react-three-gui\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const width = useControl(\"width\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const height = useControl(\"height\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const widthSegments = useControl(\"width segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const heightSegments = useControl(\"height segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const elevation = useControl(\"max elevation\", {\n    type: \"number\",\n    value: 0.25,\n    min: 0,\n    max: 2,\n  });\n  const wireframe = useControl(\"wireframe\", { type: \"boolean\", value: false });\n\n  const [colors, setColors] = useState([]);\n\n  const updatePlaneInfo = useCallback(\n    (plane) => {\n      const vertices = plane.attributes.position.array;\n      for (let i = 0; i < vertices.length; i++) {\n        if (i % 3 === 2) vertices[i] = Math.random() * elevation;\n      }\n\n      if (colors && colors.length === vertices.length) {\n        plane.setAttribute('color', new Float32BufferAttribute(colors, 3));\n      } else {\n        const zValues = [...vertices.filter((o, i) => i % 3 === 2)];\n\n        const getColor = scaleLinear()\n          .domain(extent(zValues))\n          .interpolate(() => interpolateMagma);\n\n        const vertexColors = [];\n        zValues.forEach((o) => {\n          const col = color(getColor(o));\n          vertexColors.push(col.r / 255, col.g / 255, col.b / 255);\n        });\n        setColors(() => {\n          plane.setAttribute('color', new Float32BufferAttribute(vertexColors, 3));\n          return vertexColors;\n        });\n      }\n\n      // if (plane.attributes.color) plane.attributes.color.needsUpdate = true;\n    },\n    [colors, elevation]\n  );\n\n  useEffect(() => {\n    updatePlaneInfo(ref.current);\n    ref.current.attributes.position.needsUpdate = true;\n  }, [elevation, updatePlaneInfo]);\n\n  return (\n    <mesh rotation-x={-Math.PI / 2} position-y={-1.5}>\n      <planeBufferGeometry\n        ref={ref}\n        attach=\"geometry\"\n        args={[width, height, widthSegments, heightSegments]}\n        onUpdate={(self) => updatePlaneInfo(self)}\n      >\n      </planeBufferGeometry>\n      <meshPhongMaterial\n        attach=\"material\"\n        side={DoubleSide}\n        wireframe={wireframe}\n        vertexColors={true}\n      />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const PlaneGeometry = () => {\n  return (\n    <CanvasContainer\n      text=\"Using a plane buffer geometry to show a surface plot, with colors given by d3.\"\n      xtra={<Controls />}\n    >\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useCallback, useEffect, useMemo } from \"react\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"../components/CanvasContainer\";\nimport { DoubleSide } from \"three\";\nimport { Controls, useControl } from \"react-three-gui\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const width = useControl(\"width\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const height = useControl(\"height\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const widthSegments = useControl(\"width segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const heightSegments = useControl(\"height segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const elevation = useControl(\"max elevation\", {\n    type: \"number\",\n    value: 0.35,\n    min: 0,\n    max: 2,\n  });\n  const wireframe = useControl(\"wireframe\", { type: \"boolean\", value: false });\n\n  const updatePlaneInfo = useCallback(\n    (plane) => {\n      const vertices = plane.attributes.position.array;\n      for (let i = 0; i < vertices.length; i++) {\n        if (i % 3 === 2) vertices[i] = Math.random() * elevation;\n      }\n    },\n    [elevation]\n  );\n\n  useEffect(() => {\n    updatePlaneInfo(ref.current);\n    ref.current.attributes.position.needsUpdate = true;\n  }, [elevation, updatePlaneInfo]);\n\n  const shaderData = useMemo(() => {\n    const vertexShader = /*glsl*/`\n  varying float z;\n\n  void main() {\n    vec3 pos = position;\n    z = pos.z;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = /*glsl*/`\n  varying float z;\n  \n  void main() {\n    gl_FragColor = vec4(z, 0.1, 0.3, 1.0);\n  }\n`;\n\n    return { vertexShader, fragmentShader };\n  }, []);\n\n  return (\n    <mesh rotation-x={-Math.PI / 2} position-y={-1.5}>\n      <planeBufferGeometry\n        ref={ref}\n        attach=\"geometry\"\n        args={[width, height, widthSegments, heightSegments]}\n        onUpdate={(self) => updatePlaneInfo(self)}\n      >\n      </planeBufferGeometry>\n      <shaderMaterial attach=\"material\" {...shaderData} side={DoubleSide} wireframe={wireframe} />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const PlaneGeometryShader = () => {\n  return (\n    <CanvasContainer\n      text=\"Using a plane buffer geometry to show a surface plot, with colors given by a fragment shader.\"\n      xtra={<Controls />}\n    >\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React from \"react\";\nimport { ShaderEditorLayout } from \"../components/ShaderEditorLayout\";\n\nconst VERTEX_SHADER = /*glsl*/`\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nconst FRAGMENT_SHADER = /*glsl*/`\n  varying vec2 vUv;\n  uniform float u_time;\n  uniform float u_aspect;\n  uniform vec2 u_mouse;\n\n  void main() {\n    vec2 st = vUv;\n    st.y += sin(u_time) * 0.05;\n    vec2 mouse = (u_mouse + 1.0) / 2.0;\n    gl_FragColor = vec4(st.x, st.y, (mouse.x + mouse.y) / 2.0, 1.0);\n  }\n`;\n\nexport const ShaderTemplate = () => {\n  return (\n    <ShaderEditorLayout\n      description=\"Basic template to play with shaders.\"\n      textureEnable={false}\n      vertexShader={VERTEX_SHADER}\n      fragmentShader={FRAGMENT_SHADER}\n    >\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n    </ShaderEditorLayout>\n  );\n};\n\n","import React from \"react\";\nimport { ShaderEditorLayout } from \"../components/ShaderEditorLayout\";\n\nconst VERTEX_SHADER = /*glsl*/`\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nconst FRAGMENT_SHADER = /*glsl*/`\n  varying vec2 vUv;\n  uniform float u_time;\n  uniform float u_aspect;\n  uniform vec2 u_mouse;\n\n  void main() {\n    vec2 st = vUv;\n    vec3 color = vec3(0.0);\n    vec2 mouse = u_mouse;\n\n    float d = 0.0;\n    st = st * 2. - 1.; // normalize between 0-1\n    st.x -= mouse.x;\n    st.y = step(1.0, st.y);\n    d = length( abs(st) - sin(u_time/2.0) );\n    color = vec3(st.x, st.y + mouse.y*0.25, 0.0);\n    color.b += (mouse.x + 1.0) / 2.0 * 0.35;\n    color += fract(d*12.0);\n\n    gl_FragColor=vec4(color, 1.0);\n  }\n`;\n\nexport const ShaderShapes = () => {\n  return (\n    <ShaderEditorLayout\n      description=\"Playing with shapes on shaders.\"\n      textureEnable={false}\n      vertexShader={VERTEX_SHADER}\n      fragmentShader={FRAGMENT_SHADER}\n    >\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n    </ShaderEditorLayout>\n  );\n};\n","import React, { useMemo, useEffect } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { CanvasContainer, Text } from \"../components/CanvasContainer\";\nimport { useThree, useFrame } from \"react-three-fiber\";\n\nconst Mesh = ({ bounds }) => {\n  const { mouse } = useThree();\n\n  // credits to https://www.shadertoy.com/view/MdSXzz\n  const shaderData = useMemo(() => {\n    const vertexShader = /*glsl*/`\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = /*glsl*/`\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n\n  const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n  float hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n  }\n\n  float noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                    hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                    hash( i + vec2(1.0,1.0) ), u.x), u.y);\n  }\n\n  float fbm( vec2 p )\n  {\n      float f = 0.0;\n      f += 0.5000*noise( p ); p = m*p*2.02;\n      f += 0.2500*noise( p ); p = m*p*2.03;\n      f += 0.1250*noise( p ); p = m*p*2.01;\n      f += 0.0625*noise( p );\n      return f/0.9375;\n  }\n\n  vec2 fbm2( in vec2 p )\n  {\n      return vec2( fbm(p.xy), fbm(p.yx) );\n  }\n\n  vec3 map( vec2 p )\n  {   \n      p *= 0.7;\n      float t = u_time * ( 1.0 + 2. * distance(u_mouse, vec2(0.0)));\n\n      float f = dot( fbm2( 1.0*(0.05*t + p + fbm2(-0.05*t+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) );\n\n      float bl = smoothstep( -0.8, 0.8, f );\n\n      float ti = smoothstep( -1.0, 1.0, fbm(p) );\n\n      return mix( mix( vec3(0.50,0.00,0.00), \n                       vec3(1.00,0.75,0.35), ti ), \n                       vec3(0.00,0.00,0.02), bl );\n  }\n\n  void main() {\n    vec2 p = (-u_resolution.xy+2.0*gl_FragCoord.xy)/u_resolution.y;\n\n    float e = 0.0045;\n\n    vec3 colc = map( p               ); float gc = dot(colc,vec3(0.433));\n    vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333));\n    vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333));\n    \n    vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n\n    vec3 col = colc;\n    col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb);\n    col *= 1.0+0.2*nor.y*nor.y;\n    col += 0.05*nor.y*nor.y*nor.y;\n    \n    \n    vec2 q = gl_FragCoord.xy/u_resolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    vec2 m = (u_mouse.xy + 1.0 ) / 2.0;\n    col.r *= m.x;\n    col.g *= m.y;\n    \n    gl_FragColor = vec4( col, 1.0 );\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [mouse]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nconst Xtra = () => (\n  <Text>\n    A more complex test (inspired by{\" \"}\n    {\n      <a className=\"font-semibold\" href=\"https://www.shadertoy.com/view/MdSXzz\" target=\"_black\">\n        this work\n      </a>\n    }\n    ).\n  </Text>\n);\n\nexport const ShaderTexture = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n\n  return (\n    <CanvasContainer xtra={<Xtra />} measure={ref}>\n      <Mesh bounds={bounds} />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo, useEffect, useState } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { useThree, useFrame } from \"react-three-fiber\";\nimport { CanvasContainer } from \"../components/CanvasContainer\";\nimport exampleTexture from \"./textures/texture1.png\";\nimport { ButtonImageUpload } from \"../components/ButtonImageUpload\";\nimport { loadTexture } from \"../utils\";\nimport { ShaderEditorLayout } from \"../components/ShaderEditorLayout\";\n\nconst Mesh = ({ bounds, textureUrl }) => {\n  const { mouse } = useThree();\n  const texture = useMemo(() => loadTexture(exampleTexture), []);\n\n  const shaderData = useMemo(() => {\n    const vertexShader = /*glsl*/ `\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = /*glsl*/ `\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n  uniform sampler2D u_texture;\n\n  vec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n  }\n\n  void main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5*u_resolution) / u_resolution.y;\n    vec2 mouse = (u_mouse + 1.0) / 2.0;\n\n    uv *= 1.5; // zoom \n    vec3 col = vec3(0.0);\n\n    uv.x = abs(uv.x); // reflect x coords\n\n    // shift y coord to center the graph\n    // tan(a) = y / 0.5 -> y = tan(a)*0.5\n    uv.y += tan(5.0/6.0*3.1415) * 0.5;\n\n    // setup a reflection over an angle\n    vec2 n = N(5.0/6.0*3.1415); // reflection angle\n    float d = dot(uv - vec2(0.5, 0.0), n); // vec2 sets the reflection point\n    uv -= max(0.0, d)*n*2.0;\n\n    // col += smoothstep(0.01, 0.0, abs(d)); // a line\n\n    n = N(u_mouse.y * (2.0/3.0) * 3.1415);\n    uv.x += 0.5; // compensates the 1st step on for loop ( + 1.5/3)\n    float scale = 2.0; // track the width of the lines\n\n    for(int i=0; i<10; i++) {\n      scale *= 3.0;\n      uv *= 3.0;\n      uv.x -= 1.5;\n\n      uv.x = abs(uv.x); // reflect x coords\n      uv.x -= 0.5;\n      uv -= min(0.0, dot(uv, n))*n*2.0; // reflection over angle\n      uv *= 0.9 + mouse.x * 0.1;\n    }\n\n    d = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0.0));\n    col += smoothstep(2.0 / u_resolution.y, 0.0, d/scale);\n    uv /= scale; // normalize\n    col += texture2D(u_texture, uv*2.0 + u_time*0.03).rgb;\n\n    gl_FragColor=vec4(col, 1.0);\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n      u_texture: { value: texture },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [mouse, texture]);\n\n  useEffect(() => {\n    if (textureUrl)\n      shaderData.uniforms.u_texture.value = loadTexture(textureUrl);\n  }, [textureUrl, shaderData]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nexport const FractalKoch1 = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n  const [textureUrl, setTextureUrl] = useState();\n  const handleUpload = (e) => {\n    const url = URL.createObjectURL(e.target.files[0]);\n    setTextureUrl(url);\n  };\n\n  return (\n    <CanvasContainer\n      text=\"Example of a Koch Snowflake fractal pattern, try a custom texture:\"\n      xtra={\n        <ButtonImageUpload handleUpload={handleUpload}>\n          Upload texture\n        </ButtonImageUpload>\n      }\n      measure={ref}\n    >\n      <Mesh bounds={bounds} textureUrl={textureUrl} />\n    </CanvasContainer>\n  );\n};\n\nconst VERTEX_SHADER = /*glsl*/`\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nconst FRAGMENT_SHADER = /*glsl*/ `\n  varying vec2 vUv;\n  uniform float u_time;\n  uniform float u_aspect;\n  uniform vec2 u_mouse;\n  uniform sampler2D u_texture;\n\n  vec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n  }\n\n  void main() {\n    vec2 uv = vUv - 0.5;\n    uv.x *= u_aspect;\n    vec2 mouse = (u_mouse + 1.0) / 2.0;\n\n    uv *= 1.5; // zoom \n    vec3 col = vec3(0.0);\n\n    uv.x = abs(uv.x); // reflect x coords\n\n    // shift y coord to center the graph\n    // tan(a) = y / 0.5 -> y = tan(a)*0.5\n    uv.y += tan(5.0/6.0*3.1415) * 0.5;\n\n    // setup a reflection over an angle\n    vec2 n = N(5.0/6.0*3.1415); // reflection angle\n    float d = dot(uv - vec2(0.5, 0.0), n); // vec2 sets the reflection point\n    uv -= max(0.0, d)*n*2.0;\n\n    // col += smoothstep(0.01, 0.0, abs(d)); // a line\n\n    n = N(u_mouse.y * (2.0/3.0) * 3.1415);\n    uv.x += 0.5; // compensates the 1st step on for loop ( + 1.5/3)\n    float scale = 2.0; // track the width of the lines\n\n    for(int i=0; i<10; i++) {\n      scale *= 3.0;\n      uv *= 3.0;\n      uv.x -= 1.5;\n\n      uv.x = abs(uv.x); // reflect x coords\n      uv.x -= 0.5;\n      uv -= min(0.0, dot(uv, n))*n*2.0; // reflection over angle\n      uv *= 0.9 + mouse.x * 0.1;\n    }\n\n    d = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0.0));\n    uv /= scale; // normalize\n    col += texture2D(u_texture, uv*2.0 + u_time*0.3).rgb;\n\n    gl_FragColor=vec4(col, 1.0);\n  }\n`;\n\nexport const FractalKoch = () => {\n  return (\n    <ShaderEditorLayout\n      description=\"Example of a Koch Snowflake fractal pattern, try a custom texture:\"\n      texture={exampleTexture}\n      vertexShader={VERTEX_SHADER}\n      fragmentShader={FRAGMENT_SHADER}\n    >\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n    </ShaderEditorLayout>\n  );\n};\n","import React from \"react\";\nimport { ShaderEditorLayout } from \"../components/ShaderEditorLayout\";\n\nconst VERTEX_SHADER = /*glsl*/`\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nconst FRAGMENT_SHADER = /*glsl*/`\n  varying vec2 vUv;\n  uniform float u_time;\n  uniform float u_aspect;\n  uniform vec2 u_mouse;\n  uniform sampler2D u_texture;\n\n  void main() {\n    vec2 uv = vUv - 0.5;\n    uv.x *= u_aspect;\n    vec2 mouse = (u_mouse + 1.0) / 2.0;\n    float zoom = pow(10.0, 5.0 * (0.1 - mouse.y));\n\n    vec2 c = uv*zoom*2.8;\n    c += vec2(-0.69955, 0.37999);\n\n    vec2 z = vec2(0.0);\n    float iter = 0.0;\n\n    float ma = 100.0;\n    const float max_iter = 100.0;\n\n    for(float i=0.0; i<max_iter; i++) {\n      z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c; // z^2 of a complex number\n      // ma = distance(z, mouse)*mouse.x*0.5;\n      // z *= mouse.x;\n      if(length(z) > 2.0) break;\n      iter++;\n    }\n\n    float f = iter/max_iter;\n    // f = ma;\n\n    vec3 col = vec3(f);\n    vec2 t = vec2(sin(u_time*0.1), cos(u_time*0.15))*0.5;\n    col.rb += vUv * 0.5 + t;\n    gl_FragColor=vec4(col, 1.0);\n  }\n`;\n\nexport const FractalMandelBrot = () => {\n  return (\n    <ShaderEditorLayout\n      description=\"Example of a MandelBrot fractal pattern.\"\n      textureEnable={false}\n      vertexShader={VERTEX_SHADER}\n      fragmentShader={FRAGMENT_SHADER}\n    >\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n    </ShaderEditorLayout>\n  );\n};\n","import React, { useMemo } from \"react\";\nimport { CanvasContainer } from \"../components/CanvasContainer\";\nimport { useThree, useFrame, useResource } from \"react-three-fiber\";\nimport { DoubleSide, Vector3 } from \"three\";\nimport { OrbitControls } from 'drei';\n\nconst Mesh = () => {\n  const { mouse, clock } = useThree();\n  const [ref, geometry] = useResource();\n  const { randomDirections, randomStrengths } = useMemo(() => {\n    if (!geometry) return {randomDirections: undefined, randomStrengths: undefined};\n    const triangleCount = geometry.getAttribute(\"position\").count / 3;\n    const vec3 = new Vector3();\n    const randomDirections = [];\n    const randomStrengths = [];\n\n    for (let i = 0; i < triangleCount; i++) {\n      const directions = vec3\n        .set(\n          ...Array(3)\n            .fill()\n            .map(() => Math.random())\n        )\n        .multiplyScalar(2)\n        .subScalar(1)\n        .normalize()\n        .toArray();\n      randomDirections.push(...Array(3).fill(directions).flat());\n      randomStrengths.push(...Array(3).fill(Math.random()));\n    }\n    return { randomDirections: new Float32Array(randomDirections), randomStrengths: new Float32Array(randomStrengths) };\n  }, [geometry]);\n\n  const shaderData = useMemo(() => {\n    const vertexShader = /*glsl*/ `\n  attribute vec3 randomDirections;\n  attribute float randomStrength;\n  uniform float u_explosion;\n  uniform vec2 u_mouse;\n  varying vec2 vUv;\n  varying vec3 vPos;\n\n  void main() {\n    vUv = uv;\n    vPos = position;\n    vec3 pos = position;\n    pos += randomDirections * randomStrength * pow(u_explosion*1.5, 2.0);\n    // pos += randomDirections * randomStrength * distance(u_mouse, vec2(0.0));\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = /*glsl*/ `\n  uniform float u_time;\n  uniform vec2 u_mouse;\n  varying vec2 vUv;\n  varying vec3 vPos;\n\n  void main() {\n    vec3 col = normalize(vPos) * 0.5 + 0.5;\n    gl_FragColor = vec4(col, 1.0);\n    // vec2 st = vUv;\n    // st.y += sin(u_time) * 0.05;\n    // vec2 mouse = (u_mouse + 1.0) / 2.0;\n    // gl_FragColor = vec4(st.x, st.y, (mouse.x + mouse.y) / 2.0, 1.0);\n  }\n`;\n\n    const uniforms = {\n      u_explosion: { value: 1 },\n      u_mouse: { value: mouse },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [mouse]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_explosion.value = Math.sin(clock.elapsedTime/1.5 - Math.PI/4)*0.5 + 0.5;\n  });\n\n  return (\n    <mesh>\n      {/* icosahedronBufferGeometry(radius : Float, detail : Integer) */}\n      <icosahedronBufferGeometry ref={ref} attach=\"geometry\" args={[1.5, 6]}>\n        {randomDirections && (<bufferAttribute\n          attachObject={[\"attributes\", \"randomDirections\"]}\n          count={randomDirections.length / 3}\n          array={randomDirections}\n          itemSize={3}\n        />)}\n        {randomStrengths && (<bufferAttribute\n          attachObject={[\"attributes\", \"randomStrength\"]}\n          count={randomStrengths.length}\n          array={randomStrengths}\n          itemSize={1}\n        />)}\n      </icosahedronBufferGeometry>\n      <shaderMaterial attach=\"material\" side={DoubleSide} {...shaderData} />\n    </mesh>\n  );\n};\n\nexport const ExplodingSphere = () => {\n  return (\n    <CanvasContainer text=\"An exploding sphere using vertex shaders.\">\n      <Mesh />\n      <OrbitControls />\n    </CanvasContainer>\n  );\n};\n","import React from \"react\";\nimport { ShaderEditorLayout } from \"../components/ShaderEditorLayout\";\nimport exampleTexture from \"./textures/texture1.png\";\n\nconst VERTEX_SHADER = /* glsl */ `\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0 );\n  }\n`;\n\nconst FRAGMENT_SHADER = /* glsl */ `\n  varying vec2 vUv;\n  uniform float u_time;\n  uniform float u_aspect;\n  uniform vec2 u_mouse;\n  uniform sampler2D u_texture;\n\n  void main() {\n    vec2 uv = vUv - 0.5;\n    uv.x *= u_aspect;\n    vec2 mouse = (u_mouse + 1.0) / 2.0; // 0-1\n\n    uv *= 1.0; // control zoom \n    vec3 col = vec3(0.0);\n\n\n    // Circle\n    vec2 center = vec2(0.0);\n    float r = 0.1;\n    // r = 0.1 + sin(u_time)*0.02; // using time\n    // center = clamp(u_mouse, -0.5, 0.5); // using mouse\n    float pct = distance(uv, center);\n    col += smoothstep(r, r-0.001, pct);\n\n    // col += texture2D(u_texture, vUv).rgb; // texture example\n\n    gl_FragColor=vec4(col, 1.0);\n  }\n`;\n\nexport const ShaderEditor = () => {\n  return (\n    <ShaderEditorLayout\n      description=\"A simple shader code editor\"\n      texture={exampleTexture}\n      vertexShader={VERTEX_SHADER}\n      fragmentShader={FRAGMENT_SHADER}\n      doShowCode\n    >\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n    </ShaderEditorLayout>\n  );\n};\n","import React from \"react\";\nimport {\n  HashRouter,\n  Route,\n  NavLink,\n  Switch,\n  useLocation,\n} from \"react-router-dom\";\nimport styled from \"styled-components\";\nimport { BoxGeometry } from \"./shaders/BoxGeometry\";\nimport { SurfaceD3 } from \"./shaders/SurfaceD3\";\nimport { SurfaceShader } from \"./shaders/SurfaceShader\";\nimport { CubeShader } from \"./shaders/CubeShader\";\nimport { PlaneGeometry } from \"./shaders/PlaneGeometry\";\nimport { PlaneGeometryShader } from \"./shaders/PlaneGeometryShader\";\nimport { ShaderTemplate } from \"./shaders/ShaderTemplate\";\nimport { ShaderShapes } from \"./shaders/ShaderShapes\";\nimport { ShaderTexture } from \"./shaders/ShaderTexture\";\nimport { FractalKoch } from \"./shaders/FractalKoch\";\nimport { FractalMandelBrot } from \"./shaders/FractalMandelBrot\";\nimport { ExplodingSphere } from \"./shaders/ExplodingSphere\";\nimport { ShaderEditor } from \"./shaders/ShaderEditor\";\nimport \"./index.css\";\n\nconst NLink = ({ children, ...props }) => (\n  <NavLink\n    className=\"pb-1\"\n    activeClassName=\"text-gray-400 hover:text-gray-400 font-bold\"\n    exact\n    {...props}\n  >\n    {children}\n  </NavLink>\n);\n\nconst NavBar = styled.div`\n  position: absolute;\n  display: flex;\n  flex-wrap: wrap;\n  flex-flow: column;\n  justify-content: space-between;\n  margin-top: 3rem;\n  padding: 1em 1em;\n  background-color: rgba(0, 0, 0, 0.6);\n  z-index: 100;\n  transition: all 0.2s ease-out;\n\n  ${({ isHome }) =>\n    !isHome &&\n    `\n    border-right: rgba(20, 20, 20, 0.6) 1.0rem solid;\n    transform: translateX(calc(80px - 100%));\n    padding-right: 80px;\n\n    &:hover {\n      transform: translateX(0px);\n      padding-right: 1em;\n      border-right: rgba(0, 0, 0, 0.0) 1.0rem solid;\n    }`}\n`;\n\nconst HomeContent = () => (\n  <div className=\"pt-10 text-center\">\n    <h1>Threejs Playground</h1>\n    <p className=\"mt-10\">\n      Made by: Renato Hermoza, check the{\" \"}\n      <a\n        href=\"https://github.com/renato145/threejs_playground/\"\n        target=\"_black\"\n      >\n        source code\n      </a>\n      .\n    </p>\n  </div>\n);\n\nconst AppContent = () => {\n  const location = useLocation();\n  const isHome = location.pathname === \"/\";\n\n  return (\n    <>\n      <NavBar isHome={isHome}>\n        <NLink to={`/`}>Home</NLink>\n        <NLink to={`/BoxGeometry`}>BoxGeometry</NLink>\n        <NLink to={`/SurfaceD3`}>SurfaceD3</NLink>\n        <NLink to={`/SurfaceShader`}>SurfaceShader</NLink>\n        <NLink to={`/CubeShader`}>CubeShader</NLink>\n        <NLink to={`/PlaneGeometry`}>PlaneGeometry</NLink>\n        <NLink to={`/PlaneGeometryShader`}>PlaneGeometryShader</NLink>\n        <NLink to={`/ShaderTemplate`}>ShaderTemplate</NLink>\n        <NLink to={`/ShaderShapes`}>ShaderShapes</NLink>\n        <NLink to={`/ShaderTexture`}>ShaderTexture</NLink>\n        <NLink to={`/FractalKoch`}>FractalKoch</NLink>\n        <NLink to={`/FractalMandelBrot`}>FractalMandelBrot</NLink>\n        <NLink to={`/ExplodingSphere`}>ExplodingSphere</NLink>\n        <NLink to={`/ShaderEditor`}>ShaderEditor</NLink>\n        <a\n          href=\"https://github.com/renato145/threejs_playground/\"\n          target=\"_black\"\n        >\n          Source Code\n        </a>\n      </NavBar>\n      <Switch>\n        <Route exact path={`/`}>\n          <HomeContent />\n        </Route>\n        <Route path={`/BoxGeometry`}>\n          <BoxGeometry />\n        </Route>\n        <Route path={`/SurfaceD3`}>\n          <SurfaceD3 />\n        </Route>\n        <Route path={`/SurfaceShader`}>\n          <SurfaceShader />\n        </Route>\n        <Route path={`/CubeShader`}>\n          <CubeShader />\n        </Route>\n        <Route path={`/PlaneGeometry`}>\n          <PlaneGeometry />\n        </Route>\n        <Route path={`/PlaneGeometryShader`}>\n          <PlaneGeometryShader />\n        </Route>\n        <Route path={`/ShaderTemplate`}>\n          <ShaderTemplate />\n        </Route>\n        <Route path={`/ShaderShapes`}>\n          <ShaderShapes />\n        </Route>\n        <Route path={`/ShaderTexture`}>\n          <ShaderTexture />\n        </Route>\n        <Route path={`/FractalKoch`}>\n          <FractalKoch />\n        </Route>\n        <Route path={`/FractalMandelBrot`}>\n          <FractalMandelBrot />\n        </Route>\n        <Route path={`/ExplodingSphere`}>\n          <ExplodingSphere />\n        </Route>\n        <Route path={`/ShaderEditor`}>\n          <ShaderEditor />\n        </Route>\n      </Switch>\n    </>\n  );\n};\n\nconst App = () => (\n  <HashRouter basename=\"/\">\n    <AppContent />\n  </HashRouter>\n);\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","module.exports = __webpack_public_path__ + \"static/media/texture1.72757f21.png\";"],"sourceRoot":""}