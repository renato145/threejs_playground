{"version":3,"sources":["textures/texture1.png","CanvasContainer.js","BoxGeometry.js","SurfaceD3.js","SurfaceShader.js","TestShader.js","PlaneGeometry.js","PlaneGeometryShader.js","ShaderTemplate.js","ShaderShapes.js","ShaderTexture.js","ButtonImageUpload.js","utils.js","FractalKoch.js","App.js","index.js"],"names":["module","exports","Container","styled","div","Text","CanvasContainer","text","children","xtra","measure","ref","position","Mesh","useRef","useState","hovered","setHover","useFrame","current","rotation","x","y","scale","onPointerOver","onPointerOut","attach","args","color","BoxGeometry","N","m","n","nverts","values","Array","xgrid","ygrid","j","k","i","Math","sin","PI","pow","getData","extent","xmin","xmax","xmid","xrange","ymin","ymax","ymid","yrange","zmin","zmax","zmid","zrange","scalefac","max","scalefacz","getColor","scaleLinear","domain","interpolate","interpolateMagma","useMemo","vertices","colors","push","col","r","g","b","Float32Array","faces","res","M","n0","n1","n2","n3","Uint16Array","rotation-x","onUpdate","self","console","log","computeFaceNormals","computeVertexNormals","attachObject","count","length","array","itemSize","side","DoubleSide","vertexColors","SurfaceD3","shaderData","vertexShader","fragmentShader","SurfaceShader","boxRef","uniforms","delta","value","displacement","setDisplacement","getDisplacement","useCallback","box","attributes","colorSpeed","useControl","type","distortionLvl","random","needsUpdate","TestShader","width","min","height","widthSegments","heightSegments","elevation","wireframe","setColors","updatePlaneInfo","plane","setAttribute","Float32BufferAttribute","zValues","filter","o","forEach","useEffect","position-y","PlaneGeometry","PlaneGeometryShader","bounds","mouse","useThree","u_time","u_resolution","Vector2","u_mouse","ShaderTemplate","useMeasure","polyfill","ResizeObserver","ShaderShapes","Xtra","Link","href","target","ShaderTexture","Button","button","ButtonImageUpload","handleUpload","props","style","display","accept","onChange","onClick","click","loadTexture","url","TextureLoader","load","wrapS","RepeatWrapping","wrapT","textureUrl","texture","exampleTexture","u_texture","CustomContainer","marginLeft","FractalKoch","setTextureUrl","e","URL","createObjectURL","files","BASE_URL","NLink","NavLink","attrs","exact","a","NavBar","SubText","App","to","path","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.511487e8.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/texture1.72757f21.png\";","import React from \"react\";\nimport styled from \"styled-components\";\nimport { Canvas } from \"react-three-fiber\";\nimport { Stats } from \"drei\";\n\nconst Container = styled.div`\n  height: 90vh;\n  width: 100vw;\n  & canvas:focus {\n    outline-width: 0px;\n  }\n`;\n\nexport const Text = styled.div`\n  color: #fff;\n  font-size: 1.2em;\n  text-align: center;\n  padding-top: 0.5em;\n`;\n\nexport const CanvasContainer = ({ text, children, xtra, measure }) => {\n  return (\n    <Container ref={measure}>\n      <Canvas>\n        <ambientLight />\n        <pointLight position={[10, 10, 10]} />\n        {children}\n        <Stats />\n      </Canvas>\n      {xtra && xtra}\n      {text && <Text>{text}</Text>}\n    </Container>\n  );\n};\n","import React, { useRef, useState } from \"react\";\nimport { useFrame } from \"react-three-fiber\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"./CanvasContainer\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const [hovered, setHover] = useState(false);\n\n  useFrame(() => (ref.current.rotation.x = ref.current.rotation.y += 0.01));\n\n  return (\n    <mesh\n      ref={ref}\n      scale={hovered ? [1.5, 1.5, 1.5] : [1, 1, 1]}\n      onPointerOver={() => setHover(true)}\n      onPointerOut={() => setHover(false)}\n    >\n      <boxBufferGeometry attach=\"geometry\" args={[2, 2, 2]} />\n      <meshStandardMaterial\n        attach=\"material\"\n        color={hovered ? \"hotpink\" : \"orange\"}\n      />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const BoxGeometry = () => {\n  return (\n    <CanvasContainer text=\"Simple box geometry with hover event.\">\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo } from \"react\";\nimport { DoubleSide } from \"three\";\nimport { OrbitControls } from \"drei\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\nimport { CanvasContainer } from \"./CanvasContainer\";\n\nconst M = 101,\n  N = 101;\n\nconst getData = (m, n) => {\n  var nverts = n * m;\n  var values = new Array(n * m);\n  var xgrid = new Array(n * m);\n  var ygrid = new Array(n * m);\n  for (var j = 0, k = 0; j < m; ++j) {\n    for (var i = 0; i < n; ++i, ++k) {\n      xgrid[k] = i;\n      ygrid[k] = 25 * Math.sin((i * Math.PI) / 50) + j;\n      values[k] = Math.pow(xgrid[k] - 50, 2) + Math.pow(ygrid[k] - 50, 2);\n    }\n  }\n  return { xgrid, ygrid, values, nverts };\n};\n\nconst { xgrid, ygrid, values, nverts } = getData(M, N);\n\n// Obtain centre of grid and scale factors\nconst [xmin, xmax] = extent(xgrid);\nconst xmid = 0.5 * (xmin + xmax);\nconst xrange = xmax - xmin;\n\nconst [ymin, ymax] = extent(ygrid);\nconst ymid = 0.5 * (ymin + ymax);\nconst yrange = ymax - ymin;\n\nconst [zmin, zmax] = extent(values);\nconst zmid = 0.5 * (zmin + zmax);\nconst zrange = zmax - zmin;\n\nconst scalefac = 1.2 / Math.max(xrange, yrange);\nconst scalefacz = 0.5 / zrange;\n\n// color scale\nconst getColor = scaleLinear()\n  .domain(extent(values))\n  .interpolate(() => interpolateMagma);\n\nconst Mesh = () => {\n  const [vertices, colors] = useMemo(() => {\n    const vertices = [];\n    const colors = [];\n    for (let i = 0; i < nverts; i++) {\n      vertices.push((xgrid[i] - xmid) * scalefac);\n      vertices.push((ygrid[i] - ymid) * scalefac);\n      vertices.push((values[i] - zmid) * scalefacz);\n      const col = color(getColor(values[i]));\n      colors.push(col.r / 255, col.g / 255, col.b / 255);\n    }\n    return [new Float32Array(vertices), new Float32Array(colors)];\n  }, []);\n\n  const faces = useMemo(() => {\n    const res = [];\n    for (let j = 0; j < M - 1; j++) {\n      for (let i = 0; i < N - 1; i++) {\n        const n0 = j * N + i;\n        const n1 = n0 + 1;\n        const n2 = (j + 1) * N + i + 1;\n        const n3 = n2 - 1;\n        res.push(n0, n1, n2);\n        res.push(n2, n3, n0);\n      }\n    }\n    return new Uint16Array(res);\n  }, []);\n\n  return (\n    <mesh rotation-x={-Math.PI / 2} scale={[4, 4, 4]}>\n      <bufferGeometry\n        attach=\"geometry\"\n        onUpdate={(self) => {\n          console.log(self);\n          self.computeFaceNormals();\n          self.computeVertexNormals();\n        }}\n      >\n        <bufferAttribute\n          attachObject={[\"attributes\", \"position\"]}\n          count={vertices.length / 3}\n          array={vertices}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"color\"]}\n          count={colors.length / 3}\n          array={colors}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attach=\"index\"\n          count={faces.length}\n          array={faces}\n          itemSize={1}\n        />\n      </bufferGeometry>\n      <meshPhongMaterial\n        attach=\"material\"\n        side={DoubleSide}\n        vertexColors={true}\n      />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const SurfaceD3 = () => {\n  return (\n    <CanvasContainer text=\"Surface plot using vertex and faces, colored with d3.\">\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo } from \"react\";\nimport { DoubleSide } from \"three\";\nimport { OrbitControls } from \"drei\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\nimport { CanvasContainer } from \"./CanvasContainer\";\n\nconst M = 101,\n  N = 101;\n\nconst getData = (m, n) => {\n  var nverts = n * m;\n  var values = new Array(n * m);\n  var xgrid = new Array(n * m);\n  var ygrid = new Array(n * m);\n  for (var j = 0, k = 0; j < m; ++j) {\n    for (var i = 0; i < n; ++i, ++k) {\n      xgrid[k] = i;\n      ygrid[k] = 25 * Math.sin((i * Math.PI) / 50) + j;\n      values[k] = Math.pow(xgrid[k] - 50, 2) + Math.pow(ygrid[k] - 50, 2);\n    }\n  }\n  return { xgrid, ygrid, values, nverts };\n};\n\nconst { xgrid, ygrid, values, nverts } = getData(M, N);\n\n// Obtain centre of grid and scale factors\nconst [xmin, xmax] = extent(xgrid);\nconst xmid = 0.5 * (xmin + xmax);\nconst xrange = xmax - xmin;\n\nconst [ymin, ymax] = extent(ygrid);\nconst ymid = 0.5 * (ymin + ymax);\nconst yrange = ymax - ymin;\n\nconst [zmin, zmax] = extent(values);\nconst zmid = 0.5 * (zmin + zmax);\nconst zrange = zmax - zmin;\n\nconst scalefac = 1.2 / Math.max(xrange, yrange);\nconst scalefacz = 0.5 / zrange;\n\n// color scale\nconst getColor = scaleLinear()\n  .domain(extent(values))\n  .interpolate(() => interpolateMagma);\n\nconst Mesh = () => {\n  const [vertices, colors] = useMemo(() => {\n    const vertices = [];\n    const colors = [];\n    for (let i = 0; i < nverts; i++) {\n      vertices.push((xgrid[i] - xmid) * scalefac);\n      vertices.push((ygrid[i] - ymid) * scalefac);\n      vertices.push((values[i] - zmid) * scalefacz);\n      const col = color(getColor(values[i]));\n      colors.push(col.r / 255, col.g / 255, col.b / 255);\n    }\n    return [new Float32Array(vertices), new Float32Array(colors)];\n  }, []);\n\n  const faces = useMemo(() => {\n    const res = [];\n    for (let j = 0; j < M - 1; j++) {\n      for (let i = 0; i < N - 1; i++) {\n        const n0 = j * N + i;\n        const n1 = n0 + 1;\n        const n2 = (j + 1) * N + i + 1;\n        const n3 = n2 - 1;\n        res.push(n0, n1, n2);\n        res.push(n2, n3, n0);\n      }\n    }\n    return new Uint16Array(res);\n  }, []);\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  varying float z;\n\n  void main() {\n    vec3 pos = position;\n    z = 0.41 + pos.z*1.5;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = `\n  varying float z;\n  \n  void main() {\n    gl_FragColor = vec4(z, cos(z*200.0), cos(z*100.0), 1.0);\n  }\n`;\n\n    return { vertexShader, fragmentShader };\n  }, []);\n\n  return (\n    <mesh\n      rotation-x={-Math.PI / 2}\n      // ref={ref}\n      scale={[4, 4, 4]}\n      // onPointerOver={() => setHover(true)}\n      // onPointerOut={() => setHover(false)}\n      // onPointerMove={e => console.log(e.unprojectedPoint)}\n    >\n      <bufferGeometry\n        attach=\"geometry\"\n        onUpdate={(self) => {\n          console.log(self);\n          self.computeFaceNormals();\n          self.computeVertexNormals();\n        }}\n      >\n        <bufferAttribute\n          attachObject={[\"attributes\", \"position\"]}\n          count={vertices.length / 3}\n          array={vertices}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attachObject={[\"attributes\", \"color\"]}\n          count={colors.length / 3}\n          array={colors}\n          itemSize={3}\n        />\n        <bufferAttribute\n          attach=\"index\"\n          count={faces.length}\n          array={faces}\n          itemSize={1}\n        />\n      </bufferGeometry>\n      <shaderMaterial attach=\"material\" {...shaderData} side={DoubleSide}  />\n\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const SurfaceShader = () => {\n  return (\n    <CanvasContainer text='Surface plot using vertex and faces, colored with a custom fragment shader.'>\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useState, useMemo, useCallback } from \"react\";\nimport { useFrame } from \"react-three-fiber\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { Controls, useControl } from 'react-three-gui';\n\nconst Mesh = () => {\n  const ref = useRef();\n  const boxRef = useRef();\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  attribute float displacement;\n  varying float z;\n\n  void main() {\n    vec3 pos = position;\n    z = pos.z;\n    pos.x += (displacement/1.0);\n    // pos.y += cos(displacement/2.0);\n    // pos.y += fract(displacement/2.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = `\n  uniform float delta;\n  varying float z;\n  \n  void main() {\n    gl_FragColor = vec4(z*0.5, 0.5 + cos(delta)*0.25, sin(delta), 1.0);\n  }\n`;\n\n    const uniforms = {\n      delta: { value: 0 },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, []);\n\n  const [displacement, setDisplacement] = useState();\n\n  const getDisplacement = useCallback(\n    (box) => {\n      if (displacement) return;\n      const n = box.attributes.position.count;\n      const res = new Float32Array(n);\n      setDisplacement(res);\n    },\n    [displacement]\n  );\n\n  const colorSpeed = useControl('Color speed', {type: 'number', value: 0.1, max: 10.0})\n  const distortionLvl = useControl('Distortion lvl', {type: 'number', value: 0.0, max: 1.0})\n\n  useFrame(() => {\n    ref.current.rotation.x = ref.current.rotation.y += 0.01;\n    shaderData.uniforms.delta.value += colorSpeed;\n    for (let i = 0; i < displacement.length; i++) {\n      displacement[i] = Math.random() * distortionLvl;\n    }\n    boxRef.current.attributes.displacement.needsUpdate = true;\n  });\n\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry\n        ref={boxRef}\n        attach=\"geometry\"\n        args={[3, 3, 3]}\n        onUpdate={(self) => getDisplacement(self)}\n      >\n        {displacement && (\n          <bufferAttribute\n            attachObject={[\"attributes\", \"displacement\"]}\n            count={displacement.length}\n            array={displacement}\n            itemSize={1}\n          />\n        )}\n      </boxBufferGeometry>\n      <shaderMaterial attach=\"material\" {...shaderData} />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const TestShader = () => {\n  return (\n    <CanvasContainer text=\"Testing the use of shaders.\" xtra={<Controls />}>\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useCallback, useEffect, useState } from \"react\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { DoubleSide, Float32BufferAttribute } from \"three\";\nimport { Controls, useControl } from \"react-three-gui\";\nimport { color, extent, scaleLinear, interpolateMagma } from \"d3\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const width = useControl(\"width\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const height = useControl(\"height\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const widthSegments = useControl(\"width segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const heightSegments = useControl(\"height segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const elevation = useControl(\"max elevation\", {\n    type: \"number\",\n    value: 0.25,\n    min: 0,\n    max: 2,\n  });\n  const wireframe = useControl(\"wireframe\", { type: \"boolean\", value: false });\n\n  const [colors, setColors] = useState([]);\n\n  const updatePlaneInfo = useCallback(\n    (plane) => {\n      const vertices = plane.attributes.position.array;\n      for (let i = 0; i < vertices.length; i++) {\n        if (i % 3 === 2) vertices[i] = Math.random() * elevation;\n      }\n\n      if (colors && colors.length === vertices.length) {\n        plane.setAttribute('color', new Float32BufferAttribute(colors, 3));\n      } else {\n        const zValues = [...vertices.filter((o, i) => i % 3 === 2)];\n\n        const getColor = scaleLinear()\n          .domain(extent(zValues))\n          .interpolate(() => interpolateMagma);\n\n        const vertexColors = [];\n        zValues.forEach((o) => {\n          const col = color(getColor(o));\n          vertexColors.push(col.r / 255, col.g / 255, col.b / 255);\n        });\n        setColors(() => {\n          plane.setAttribute('color', new Float32BufferAttribute(vertexColors, 3));\n          return vertexColors;\n        });\n      }\n\n      // if (plane.attributes.color) plane.attributes.color.needsUpdate = true;\n    },\n    [colors, elevation]\n  );\n\n  useEffect(() => {\n    updatePlaneInfo(ref.current);\n    ref.current.attributes.position.needsUpdate = true;\n  }, [elevation, updatePlaneInfo]);\n\n  return (\n    <mesh rotation-x={-Math.PI / 2} position-y={-1.5}>\n      <planeBufferGeometry\n        ref={ref}\n        attach=\"geometry\"\n        args={[width, height, widthSegments, heightSegments]}\n        onUpdate={(self) => updatePlaneInfo(self)}\n      >\n      </planeBufferGeometry>\n      <meshPhongMaterial\n        attach=\"material\"\n        side={DoubleSide}\n        wireframe={wireframe}\n        vertexColors={true}\n      />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const PlaneGeometry = () => {\n  return (\n    <CanvasContainer\n      text=\"Using a plane buffer geometry to show a surface plot, with colors given by d3.\"\n      xtra={<Controls />}\n    >\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef, useCallback, useEffect, useMemo } from \"react\";\nimport { OrbitControls } from \"drei\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { DoubleSide } from \"three\";\nimport { Controls, useControl } from \"react-three-gui\";\n\nconst Mesh = () => {\n  const ref = useRef();\n  const width = useControl(\"width\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const height = useControl(\"height\", {\n    type: \"number\",\n    value: 5,\n    min: 1,\n    max: 10,\n  });\n  const widthSegments = useControl(\"width segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const heightSegments = useControl(\"height segments\", {\n    type: \"number\",\n    value: 10,\n    min: 2,\n    max: 100,\n  });\n  const elevation = useControl(\"max elevation\", {\n    type: \"number\",\n    value: 0.35,\n    min: 0,\n    max: 2,\n  });\n  const wireframe = useControl(\"wireframe\", { type: \"boolean\", value: false });\n\n  const updatePlaneInfo = useCallback(\n    (plane) => {\n      const vertices = plane.attributes.position.array;\n      for (let i = 0; i < vertices.length; i++) {\n        if (i % 3 === 2) vertices[i] = Math.random() * elevation;\n      }\n    },\n    [elevation]\n  );\n\n  useEffect(() => {\n    updatePlaneInfo(ref.current);\n    ref.current.attributes.position.needsUpdate = true;\n  }, [elevation, updatePlaneInfo]);\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  varying float z;\n\n  void main() {\n    vec3 pos = position;\n    z = pos.z;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\n    const fragmentShader = `\n  varying float z;\n  \n  void main() {\n    gl_FragColor = vec4(z, 0.1, 0.3, 1.0);\n  }\n`;\n\n    return { vertexShader, fragmentShader };\n  }, []);\n\n  return (\n    <mesh rotation-x={-Math.PI / 2} position-y={-1.5}>\n      <planeBufferGeometry\n        ref={ref}\n        attach=\"geometry\"\n        args={[width, height, widthSegments, heightSegments]}\n        onUpdate={(self) => updatePlaneInfo(self)}\n      >\n      </planeBufferGeometry>\n      <shaderMaterial attach=\"material\" {...shaderData} side={DoubleSide} wireframe={wireframe} />\n      <OrbitControls />\n    </mesh>\n  );\n};\n\nexport const PlaneGeometryShader = () => {\n  return (\n    <CanvasContainer\n      text=\"Using a plane buffer geometry to show a surface plot, with colors given by a fragment shader.\"\n      xtra={<Controls />}\n    >\n      <Mesh />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo, useEffect } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { useThree, useFrame } from \"react-three-fiber\";\n\nconst Mesh = ({ bounds }) => {\n  const { mouse } = useThree();\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = `\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n\n\n  void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.y += sin(u_time) * 0.05;\n    vec2 mouse = (u_mouse + 1.0) / 2.0;\n    gl_FragColor=vec4(st.x, st.y, (mouse.x + mouse.y) / 2.0, 1.0);\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [ mouse ]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nexport const ShaderTemplate = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n\n  return (\n    <CanvasContainer text=\"Basic template to play with shaders.\" measure={ref}>\n      <Mesh bounds={bounds} />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo, useEffect } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { useThree, useFrame } from \"react-three-fiber\";\n\nconst Mesh = ({ bounds }) => {\n  const { mouse } = useThree();\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = `\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n\n  void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 mouse = u_mouse;\n\n    // Borders\n    // vec2 bl = smoothstep(0.05, 0.5, st);\n    // float pct = bl.x * bl.y;\n    // vec2 tr = step(0.05, 1.0 - st);\n    // pct *= tr.x * tr.y;\n    // color = vec3(pct);\n\n    // Circle\n    // float pct = distance(st, vec2(0.5));\n    // color = vec3(pct);\n\n    // Repeating circles\n    float d = 0.0;\n    st = st * 2. - 1.; // normalize between 0-1\n    st.x -= mouse.x;\n    // st.y -= mouse.y;\n    st.y = step(1.0, st.y);\n    // st.y = smoothstep(-1.0, 1.0, st.y);\n    d = length( abs(st) - sin(u_time/20.0) );\n    color = vec3(st.x, st.y + mouse.y*0.25, 0.0);\n    color.b += (mouse.x + 1.0) / 2.0 * 0.35;\n    color += fract(d*12.0);\n\n    gl_FragColor=vec4(color, 1.0);\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [ mouse ]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nexport const ShaderShapes = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n\n  return (\n    <CanvasContainer text=\"Playing with shapes on shaders.\" measure={ref}>\n      <Mesh bounds={bounds} />\n    </CanvasContainer>\n  );\n};\n","import React, { useMemo, useEffect } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { CanvasContainer, Text } from \"./CanvasContainer\";\nimport { Link } from \"./App\";\nimport { useThree, useFrame } from \"react-three-fiber\";\n\nconst Mesh = ({ bounds }) => {\n  const { mouse } = useThree();\n\n  // credits to https://www.shadertoy.com/view/MdSXzz\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = `\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n\n  const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n  float hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n  }\n\n  float noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                    hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                    hash( i + vec2(1.0,1.0) ), u.x), u.y);\n  }\n\n  float fbm( vec2 p )\n  {\n      float f = 0.0;\n      f += 0.5000*noise( p ); p = m*p*2.02;\n      f += 0.2500*noise( p ); p = m*p*2.03;\n      f += 0.1250*noise( p ); p = m*p*2.01;\n      f += 0.0625*noise( p );\n      return f/0.9375;\n  }\n\n  vec2 fbm2( in vec2 p )\n  {\n      return vec2( fbm(p.xy), fbm(p.yx) );\n  }\n\n  vec3 map( vec2 p )\n  {   \n      p *= 0.7;\n      float t = u_time * ( 1.0 + 2. * distance(u_mouse, vec2(0.0)));\n\n      float f = dot( fbm2( 1.0*(0.05*t + p + fbm2(-0.05*t+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) );\n\n      float bl = smoothstep( -0.8, 0.8, f );\n\n      float ti = smoothstep( -1.0, 1.0, fbm(p) );\n\n      return mix( mix( vec3(0.50,0.00,0.00), \n                       vec3(1.00,0.75,0.35), ti ), \n                       vec3(0.00,0.00,0.02), bl );\n  }\n\n  void main() {\n    vec2 p = (-u_resolution.xy+2.0*gl_FragCoord.xy)/u_resolution.y;\n\n    float e = 0.0045;\n\n    vec3 colc = map( p               ); float gc = dot(colc,vec3(0.433));\n    vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333));\n    vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333));\n    \n    vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n\n    vec3 col = colc;\n    col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb);\n    col *= 1.0+0.2*nor.y*nor.y;\n    col += 0.05*nor.y*nor.y*nor.y;\n    \n    \n    vec2 q = gl_FragCoord.xy/u_resolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    vec2 m = (u_mouse.xy + 1.0 ) / 2.0;\n    col.r *= m.x;\n    col.g *= m.y;\n    \n    gl_FragColor = vec4( col, 1.0 );\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [mouse]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nconst Xtra = () => (\n  <Text>\n    A more complex test (inspired by{\" \"}\n    {\n      <Link href=\"https://www.shadertoy.com/view/MdSXzz\" target=\"_black\">\n        this work\n      </Link>\n    }\n    ).\n  </Text>\n);\n\nexport const ShaderTexture = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n\n  return (\n    <CanvasContainer xtra={<Xtra />} measure={ref}>\n      <Mesh bounds={bounds} />\n    </CanvasContainer>\n  );\n};\n","import React, { useRef } from \"react\";\nimport styled from \"styled-components\";\n\nconst Button = styled.button`\n  text-align: center;\n  vertical-align: middle;\n  background-color: #ccc;\n  color: #111;\n  border: 1px solid transparent;\n  padding: 0.175rem 0.75rem;\n  line-height: 1.5;\n  border-radius: 0.25rem;\n  transition: all 0.2s ease-out;\n\n  &:hover {\n    background-color: #666;\n    color: #fff;\n  }\n`;\n\nexport const ButtonImageUpload = ({\n  text = \"Upload Image\",\n  handleUpload = () => {},\n  ...props\n}) => {\n  const ref = useRef();\n\n  return (\n    <div {...props}>\n      <input\n        ref={ref}\n        type=\"file\"\n        style={{ display: \"none\" }}\n        accept=\"image/*\"\n        onChange={handleUpload}\n      />\n      <Button\n        onClick={() => ref.current.click()}\n        // disabled={disableButtons}\n      >\n        {text}\n      </Button>\n    </div>\n  );\n};\n","import { TextureLoader, RepeatWrapping } from \"three\";\n\nexport const loadTexture = url => {\n  const res = new TextureLoader().load(url);\n  res.wrapS = RepeatWrapping;\n  res.wrapT = RepeatWrapping;\n  return res;\n}\n","import React, { useMemo, useEffect, useState } from \"react\";\nimport { Vector2 } from \"three\";\nimport useMeasure from \"react-use-measure\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { useThree, useFrame } from \"react-three-fiber\";\nimport styled from \"styled-components\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport { Text } from \"./CanvasContainer\";\nimport exampleTexture from \"./textures/texture1.png\";\nimport { ButtonImageUpload } from \"./ButtonImageUpload\";\nimport { loadTexture } from './utils';\n\nconst Mesh = ({ bounds, textureUrl }) => {\n  const { mouse } = useThree();\n  const texture = useMemo(() => loadTexture(exampleTexture), []);\n\n  const shaderData = useMemo(() => {\n    const vertexShader = `\n  void main() {\n    gl_Position = vec4( position, 1.0 );\n  }\n`;\n\n    const fragmentShader = `\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n  uniform sampler2D u_texture;\n\n  vec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n  }\n\n  void main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5*u_resolution) / u_resolution.y;\n    vec2 mouse = (u_mouse + 1.0) / 2.0;\n\n    uv *= 1.5; // zoom \n    vec3 col = vec3(0.0);\n\n    uv.x = abs(uv.x); // reflect x coords\n\n    // shift y coord to center the graph\n    // tan(a) = y / 0.5 -> y = tan(a)*0.5\n    uv.y += tan(5.0/6.0*3.1415) * 0.5;\n\n    // setup a reflection over an angle\n    vec2 n = N(5.0/6.0*3.1415); // reflection angle\n    float d = dot(uv - vec2(0.5, 0.0), n); // vec2 sets the reflection point\n    uv -= max(0.0, d)*n*2.0;\n\n    // col += smoothstep(0.01, 0.0, abs(d)); // a line\n\n    n = N(u_mouse.y * (2.0/3.0) * 3.1415);\n    uv.x += 0.5; // compensates the 1st step on for loop ( + 1.5/3)\n    float scale = 2.0; // track the width of the lines\n\n    for(int i=0; i<10; i++) {\n      scale *= 3.0;\n      uv *= 3.0;\n      uv.x -= 1.5;\n\n      uv.x = abs(uv.x); // reflect x coords\n      uv.x -= 0.5;\n      uv -= min(0.0, dot(uv, n))*n*2.0; // reflection over angle\n      uv *= 0.9 + mouse.x * 0.1;\n    }\n\n    d = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0.0));\n    col += smoothstep(2.0 / u_resolution.y, 0.0, d/scale);\n    uv /= scale; // normalize\n    col += texture2D(u_texture, uv*2.0 + u_time*0.03).rgb;\n\n    gl_FragColor=vec4(col, 1.0);\n  }\n`;\n\n    const uniforms = {\n      u_time: { value: 0 },\n      u_resolution: { value: new Vector2() },\n      u_mouse: { value: mouse },\n      u_texture: { value: texture },\n    };\n\n    return { vertexShader, fragmentShader, uniforms };\n  }, [mouse, texture]);\n\n  useEffect(() => {\n    if (textureUrl) shaderData.uniforms.u_texture.value = loadTexture(textureUrl);\n  }, [textureUrl, shaderData]);\n\n  useEffect(() => {\n    shaderData.uniforms.u_resolution.value.x = bounds.width;\n    shaderData.uniforms.u_resolution.value.y = bounds.height;\n  }, [bounds, shaderData]);\n\n  useFrame(() => {\n    shaderData.uniforms.u_time.value += 0.05;\n  });\n\n  return (\n    <mesh>\n      <planeBufferGeometry  attach=\"geometry\" args={[2, 2]} />\n      <shaderMaterial attach=\"material\" {...shaderData} />\n    </mesh>\n  );\n};\n\nconst CustomContainer = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  flex-flow: row;\n  justify-content: center;\n  padding-top: 0.5rem;\n`;\n\nconst Xtra = ({ handleUpload }) => (\n  <CustomContainer>\n    <Text>\n      Example of a Koch Snowflake fractal pattern, try a custom patter:\n    </Text>\n    <ButtonImageUpload style={{ marginLeft: \"0.5em\" }} text=\"Upload texture\" handleUpload={handleUpload} />\n  </CustomContainer>\n);\n\nexport const FractalKoch = () => {\n  const [ref, bounds] = useMeasure({ polyfill: ResizeObserver });\n  const [textureUrl, setTextureUrl] = useState();\n  const handleUpload = (e) => {\n    const url = URL.createObjectURL(e.target.files[0]);\n    setTextureUrl(url);\n  };\n\n  return (\n    <CanvasContainer xtra={<Xtra handleUpload={handleUpload} />} measure={ref}>\n      <Mesh bounds={bounds} textureUrl={textureUrl} />\n    </CanvasContainer>\n  );\n};\n","import React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Route,\n  NavLink,\n  Switch,\n} from \"react-router-dom\";\nimport styled from \"styled-components\";\nimport { BoxGeometry } from \"./BoxGeometry\";\nimport { SurfaceD3 } from \"./SurfaceD3\";\nimport { SurfaceShader } from \"./SurfaceShader\";\nimport { TestShader } from \"./TestShader\";\nimport { PlaneGeometry } from \"./PlaneGeometry\";\nimport { PlaneGeometryShader } from \"./PlaneGeometryShader\";\nimport { ShaderTemplate } from \"./ShaderTemplate\";\nimport { ShaderShapes } from \"./ShaderShapes\";\nimport { ShaderTexture } from \"./ShaderTexture\";\nimport { FractalKoch } from \"./FractalKoch\";\nimport \"./App.css\";\n\nconst BASE_URL = \"threejs_playground\";\n\nconst NLink = styled(NavLink).attrs((props) => ({\n  exact: true,\n}))`\n  color: #abc;\n  font-size: 1rem;\n  &.active {\n    color: #fff;\n  }\n`;\n\nexport const Link = styled.a`\n  color: #abc;\n  font-size: 1rem;\n  &.active {\n    color: #fff;\n  }\n`;\n\nconst NavBar = styled.div`\n  position: absolute;\n  display: flex;\n  flex-wrap: wrap;\n  flex-flow: column;\n  justify-content: space-between;\n  margin-top: 3rem;\n  padding: 1em 1em;\n  background-color: rgba(0, 0, 0, 0.6);\n  z-index: 100;\n\n  & > div {\n    padding-bottom: 0.5rem;\n  }\n`;\n\nconst Text = styled.div`\n  color: #fff;\n  font-size: 2em;\n  text-align: center;\n  padding-top: 2em;\n`;\n\nconst SubText = styled.div`\n  color: #fff;\n  font-size: 1.2em;\n  text-align: center;\n  padding-top: 3em;\n`;\n\nconst App = () => {\n  return (\n    <Router>\n      <NavBar>\n        <div>\n          <NLink to={`/${BASE_URL}/`}>Home</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/BoxGeometry`}>BoxGeometry</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/SurfaceD3`}>SurfaceD3</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/SurfaceShader`}>SurfaceShader</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/TestShader`}>TestShader</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/PlaneGeometry`}>PlaneGeometry</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/PlaneGeometryShader`}>\n            PlaneGeometryShader\n          </NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/ShaderTemplate`}>ShaderTemplate</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/ShaderShapes`}>ShaderShapes</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/ShaderTexture`}>ShaderTexture</NLink>\n        </div>\n        <div>\n          <NLink to={`/${BASE_URL}/FractalKoch`}>FractalKoch</NLink>\n        </div>\n        <div>\n          <Link\n            href=\"https://github.com/renato145/threejs_playground/\"\n            target=\"_black\"\n          >\n            Source Code\n          </Link>\n        </div>\n      </NavBar>\n      <Switch>\n        <Route exact path={`/${BASE_URL}/`}>\n          <Text>Threejs playground</Text>\n          <SubText>\n            Made by: Renato Hermoza, check the{\" \"}\n            <Link\n              href=\"https://github.com/renato145/threejs_playground/\"\n              target=\"_black\"\n            >\n              source code\n            </Link>\n            .\n          </SubText>\n        </Route>\n        <Route path={`/${BASE_URL}/BoxGeometry`}>\n          <BoxGeometry />\n        </Route>\n        <Route path={`/${BASE_URL}/SurfaceD3`}>\n          <SurfaceD3 />\n        </Route>\n        <Route path={`/${BASE_URL}/SurfaceShader`}>\n          <SurfaceShader />\n        </Route>\n        <Route path={`/${BASE_URL}/TestShader`}>\n          <TestShader />\n        </Route>\n        <Route path={`/${BASE_URL}/PlaneGeometry`}>\n          <PlaneGeometry />\n        </Route>\n        <Route path={`/${BASE_URL}/PlaneGeometryShader`}>\n          <PlaneGeometryShader />\n        </Route>\n        <Route path={`/${BASE_URL}/ShaderTemplate`}>\n          <ShaderTemplate />\n        </Route>\n        <Route path={`/${BASE_URL}/ShaderShapes`}>\n          <ShaderShapes />\n        </Route>\n        <Route path={`/${BASE_URL}/ShaderTexture`}>\n          <ShaderTexture />\n        </Route>\n        <Route path={`/${BASE_URL}/FractalKoch`}>\n          <FractalKoch />\n        </Route>\n      </Switch>\n    </Router>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}